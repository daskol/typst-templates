--- a/corpus/biblio/bibtex/contrib/econ-bst/econ-no-sort.bst	2025-10-26 16:46:56.478710958 +0300
+++ b/corpus/biblio/bibtex/contrib/econ-bst/econ-no-sort.bst	2025-10-26 16:47:03.983361687 +0300
@@ -1,4 +1,4 @@
-n%% econ.bst: BibTeX style file for papers in economics.
+%% econ.bst: BibTeX style file for papers in economics.
 %
 % Author: Shiro Takeda
 % Maintainer: Shiro Takeda
--- a/corpus/biblio/bibtex/utils/refer-tools/refer.bst	2025-10-26 16:48:08.741576683 +0300
+++ b/corpus/biblio/bibtex/utils/refer-tools/refer.bst	2025-10-26 16:48:41.679111952 +0300
@@ -302,86 +302,3 @@
 READ
 
 ITERATE {call.type$}
-------------------- End of file "refer.bst" ---------------------
-
-------------------- Start of file "bib2refer" ---------------------
-#! /bin/sh
-# Written by Ciaran McHale (cjmchale@cs.tcd.ie) 8/4/'90
-
-FN=`basename $0`
-
-case $# in
-0)      echo "Usage: $FN <filename> [<filename>*]" ; exit 1 ;;
-esac
-
-#
-# This shell script uses bibtex and a custom made bibliography style file
-# to translate BibTeX bibliographies into refer format. It is based on
-# another shell script written by Eamonn McManus, Alan Judge and Ciaran McHale.
-#
-STYLE=refer     # BibTeX-to-refer style file
-
-FILE=tmp
-RESULT=${FN}.out
-BIBFILE=${FILE}.bib
-
-# clean up if interrupted
-trap 'rm ${FILE}.bbl ${FILE}.aux ${FILE}.blg ; exit 1' 1 2 3 15
-
-> ${FILE}.bbl           # truncate the files
-> ${FILE}.aux
-> ${FILE}.blg
-
-#
-#Hand craft the .aux file
-#
-BIBRECD=""
-for i
-do
-        file="`echo $i | sed 's/.bib//'`"
-        BIBRECD="${BIBRECD},${file}"
-done
-BIBRECD="`echo $BIBRECD | sed 's/^,//'`"        # remove 1st " "
-
-echo "\bibstyle{$STYLE}"        >> ${FILE}.aux
-echo "\bibdata{$BIBRECD}"       >> ${FILE}.aux
-
-# Read all the files (command line arguments) and use them to write
-# the necessary info into the .aux file.
-for i
-do
-        file="`echo $i | sed 's/.bib//'`"
-        bibfile=${file}.bib
-        echo FILE $bibfile has `egrep '^@' $bibfile | wc -l` records
-        # create the .aux file with \citation commands in it
-        sed -n 's/^@.*[{(][     ]*\(.*\)/\\citation {\1}/p' $bibfile  |
-                sed 's/[,       ]//g' >>${FILE}.aux
-
-done
-
-bibtex $FILE
-cp ${FILE}.bbl ${RESULT}
-
-echo; echo ${FN}: output in ${RESULT}; echo
-
-# Cleanup...
-rm ${FILE}.bbl ${FILE}.aux ${FILE}.blg
-
-exit 0
-------------------- End of file "bib2refer" ---------------------
-
-
-This was written as a quick hack and I haven't tested it thoroughly so
-if you see any problems then be prepared to get out the BibTeX
-programming manual and change a line or two (hopefully that won't be
-necessary).
-
-
-Ciaran.
---
-Ciaran McHale
-Department of Computer Science, Trinity College, Dublin 2, Ireland.
-Telephone: +353-1-772941 ext 1538    FAX: +353-1-772204   Telex: 93782 TCD EI
-email: cjmchale@cs.tcd.ie       or      cjmchale%cs.tcd.ie@cunyvm.cuny.edu
-        My opinions and bad language do not represent Trinity
-
--- a/corpus/macros/latex/contrib/seuthesix/seuthesix.bst	2025-10-26 16:57:55.954636877 +0300
+++ b/corpus/macros/latex/contrib/seuthesix/seuthesix.bst	2025-10-26 16:58:04.905659240 +0300
@@ -455,7 +455,7 @@
 		  year "-" * "[" *
 		  language missing$
 		  {month empty}
-		  {缺少月份}
+		  {"缺少月份"}
 		  if$
 		  "]-" * day *
 		  }
--- a/corpus/macros/latex/contrib/uestcthesis/uestcthesis.bst	2025-10-26 16:56:52.362165779 +0300
+++ b/corpus/macros/latex/contrib/uestcthesis/uestcthesis.bst	2025-10-26 16:56:57.072478422 +0300
@@ -3135,6 +3135,5 @@
 
 EXECUTE {end.bib}
 
-\endinput
 %%
 %% End of file `uestcthesis.bst'.
--- a/corpus/obsolete/biblio/bibtex/contrib/cea.bst	2025-10-26 16:36:36.194807448 +0300
+++ b/corpus/obsolete/biblio/bibtex/contrib/cea.bst	2025-10-26 16:36:39.944388499 +0300
@@ -1121,4 +1121,3 @@
 }
 
 EXECUTE {end.bib}
-
\ No newline at end of file
--- a/corpus/obsolete/biblio/bibtex/contrib/geralpha/geralpha.bst	2025-10-26 16:37:12.161152028 +0300
+++ b/corpus/obsolete/biblio/bibtex/contrib/geralpha/geralpha.bst	2025-10-26 16:37:26.325301312 +0300
@@ -1,13 +1,3 @@
-Received: From DHDURZ1(MAILER) by DS0RUS54 with Jnet id 2694
-          for ZRFN0370@DS0RUS54; Mon, 15 Oct 90 14:27 A
-Received: from DHDURZ1 (DANTE) by DHDURZ1 (Mailer R2.03B) with BSMTP id 2687;
- Mon, 15 Oct 90 14:25:48 CET
-Date:         Mon, 15 Oct 90 14:24:52 CET
-From:         "DANTE e.V." <DANTE@DHDURZ1>
-Subject:      geralpha.bst
-To:           Barbara Burr <ZRFN0370@DS0RUS54>
- 
- 
 %
 % Adapted bibliography style `geralpha' that changes several english-language
 % ``constants'' in the style.
--- a/corpus/obsolete/biblio/bibtex/contrib/physics.bst	2025-10-26 16:44:39.022134834 +0300
+++ b/corpus/obsolete/biblio/bibtex/contrib/physics.bst	2025-10-26 16:45:37.143008802 +0300
@@ -3,252 +3,49 @@
 % This file, physics.bst, is based on the file btxbst.doc.
         % Please notify Charles Karney (Karney%PPC.MFEnet@NMFECC.ARPA)
         % of any bugs, improvements, etc.
-
-% Run this file through cpp to get specific versions.  I have written
-% a version of cpp within Emacs.  To access it put
-%       (autoload 'cpp "tex$bibtex:cpp"         ; Use cpp for BibTeX styles
-%                 "C preprocessor"
-%                 t)
-% into your .emacs file.  Read in this file with
-%       emacs tex$bibtex:physics.bst
+% Run this file through cpp to get specific versions. I have written
+% a version of cpp within Emacs. To access it put
+% (autoload 'cpp "tex$bibtex:cpp"         ; Use cpp for BibTeX styles
+% "C preprocessor"
+% t)
+% into your .emacs file. Read in this file with
+% emacs tex$bibtex:physics.bst
 % and run cpp with e.g.,
-%       M-x cpp <ret> aip <ret>
+% M-x cpp <ret> aip <ret>
 % Save the resulting file to tex$latex:aip.bst.
-
 % To accomodate the variations we need (in addition to the definitions below)
-%       ATIT_SUPPRESS:  do not include the titles of journal articles
-%       NAME_INVERT:    put the initials last
-%       NAME_UPPER:     convert names to all caps.
-%       MONTH_SUPPRESS: do not include months in journal articles
-%       PAREN_DATE:     dates go in parens in journal articles
-%       DATE_FIRST:     dates go before page numbers
-%       VOLUME_SPACE:   volume set off with space (not colon)
-%       NUM_SUPPRESS:   do not include numbers in journal articles
-%       BOLD_VOL:       volume numbers in bold face in journal articles
-%       BRACKET_NOTE:   notes in brackets
-%       PAGE_START_J:   include only starting page for journal articles
-%       PAGE_START_O:   include only starting page for other entries
-%       PAGE_ABBREV:    abbreviate page to p. and pages to pp.
-%       PHYSICS_JOUR:   include abbreviations for Physics journals
-%       COMMA_DELIMIT:  use comma (instead of period) to divide a citation
-%       NOTE_SUPPRESS:  suppress the note
-%       NOTE_BRACKET:   put note in brackets
-%       MAX_NAMES:      max number of authors before using et al (0 = infinity)
-%       MIN_NAMES:      number of authors to list with et al.
-%       EDIT_VAR:       use "edited by ..." instead of "..., editors"
-%       RMP_LABELS:     create RMP-style labels
-%       KEY_CITE:       use key as label
-%       NAMED_REFS:     use (Smith, 1988) style of citations
-%       CSC_NAMES:      names set in caps and small caps
-%       JOUR_DEEMPH:    don't emphasize journal name
-%       ETAL_EMPH:      emphasize et al.
-
+% ATIT_SUPPRESS: do not include the titles of journal articles
+% NAME_INVERT: put the initials last
+% NAME_UPPER: convert names to all caps.
+% MONTH_SUPPRESS: do not include months in journal articles
+% PAREN_DATE: dates go in parens in journal articles
+% DATE_FIRST: dates go before page numbers
+% VOLUME_SPACE: volume set off with space (not colon)
+% NUM_SUPPRESS: do not include numbers in journal articles
+% BOLD_VOL: volume numbers in bold face in journal articles
+% BRACKET_NOTE: notes in brackets
+% PAGE_START_J: include only starting page for journal articles
+% PAGE_START_O: include only starting page for other entries
+% PAGE_ABBREV: abbreviate page to p. and pages to pp.
+% PHYSICS_JOUR: include abbreviations for Physics journals
+% COMMA_DELIMIT: use comma (instead of period) to divide a citation
+% NOTE_SUPPRESS: suppress the note
+% NOTE_BRACKET: put note in brackets
+% MAX_NAMES: max number of authors before using et al (0 = infinity)
+% MIN_NAMES: number of authors to list with et al.
+% EDIT_VAR: use "edited by ..." instead of "..., editors"
+% RMP_LABELS: create RMP-style labels
+% KEY_CITE: use key as label
+% NAMED_REFS: use (Smith, 1988) style of citations
+% CSC_NAMES: names set in caps and small caps
+% JOUR_DEEMPH: don't emphasize journal name
+% ETAL_EMPH: emphasize et al.
 % These are all boolean (0 or 1) except for MAX_NAMES and MIN_NAMES.
 % These need to satisfy 0 <= MIN_NAMES <= MAX_NAMES.
 % The rule here is that if all these are defined to be zero, we revert to
-% the standard styles.  For that reason we initialize them all to 0.
-
-#   define ATIT_SUPPRESS 0
-#   define NAME_INVERT 0
-#   define NAME_UPPER 0
-#   define MONTH_SUPPRESS 0
-#   define PAREN_DATE 0
-#   define DATE_FIRST 0
-#   define VOLUME_SPACE 0
-#   define NUM_SUPPRESS 0
-#   define BOLD_VOL 0
-#   define BRACKET_NOTE 0
-#   define PAGE_START_J 0
-#   define PAGE_START_O 0
-#   define PAGE_ABBREV 0
-#   define PHYSICS_JOUR 0
-#   define COMMA_DELIMIT 0
-#   define NOTE_SUPPRESS 0
-#   define NOTE_BRACKET 0
-#   define MAX_NAMES 0
-#   define MIN_NAMES 0
-#   define EDIT_VAR 0
-#   define RMP_LABELS 0
-#   define KEY_CITE 0
-#   define NAMED_REFS 0
-#   define CSC_NAMES 0
-#   define JOUR_DEEMPH 0
-#   define ETAL_EMPH 0
-
+% the standard styles. For that reason we initialize them all to 0.
 % These are the original macros
-#   define LAB_ALPH 0
-#   define SORTED 0
-#   define NAME_FULL 0
-#   define ATIT_LOWER 0
-#   define MONTH_FULL 0
-#   define JOUR_FULL 0
-
-#ifdef AIP
-        % For American Institute of Physics Journals
-#   define ATIT_SUPPRESS 1
-#   define PAGE_START_J 1
-#   define PHYSICS_JOUR 1
-#   define MAX_NAMES 5
-#   define MIN_NAMES 1
-#   define EDIT_VAR 1
-#   define ATIT_LOWER 1
-#   define COMMA_DELIMIT 1
-#   define VOLUME_SPACE 1
-#   define MONTH_SUPPRESS 1
-#   define PAREN_DATE 1
-#   define NUM_SUPPRESS 1
-#   define BOLD_VOL 1
-#   define JOUR_DEEMPH 1
-#endif
-#ifdef NF
-        % For Nuclear Fusion
-% same as AIP except for NAME_INVERT, NAME_UPPER, DATE_FIRST and 
-%  MIN_NAMES and MAX_NAMES set to 0 (infinity)
-#   define ATIT_SUPPRESS 1
-#   define PAGE_START_J 1
-#   define PHYSICS_JOUR 1
-#   define EDIT_VAR 1
-#   define ATIT_LOWER 1
-#   define COMMA_DELIMIT 1
-#   define VOLUME_SPACE 1
-#   define MONTH_SUPPRESS 1
-#   define PAREN_DATE 1
-#   define NUM_SUPPRESS 1
-#   define BOLD_VOL 1
-#   define NAME_INVERT 1
-#   define NAME_UPPER 1
-#   define DATE_FIRST 1
-#   define JOUR_DEEMPH 1
-#endif
-#ifdef NFLET
-        % For Nuclear Fusion Letters
-% same as NF except for MIN_NAMES and MAX_NAMES set to 5
-#   define ATIT_SUPPRESS 1
-#   define PAGE_START_J 1
-#   define PHYSICS_JOUR 1
-#   define EDIT_VAR 1
-#   define ATIT_LOWER 1
-#   define COMMA_DELIMIT 1
-#   define VOLUME_SPACE 1
-#   define MONTH_SUPPRESS 1
-#   define PAREN_DATE 1
-#   define NUM_SUPPRESS 1
-#   define BOLD_VOL 1
-#   define NAME_INVERT 1
-#   define NAME_UPPER 1
-#   define DATE_FIRST 1
-#   define MAX_NAMES 5
-#   define MIN_NAMES 5
-#   define JOUR_DEEMPH 1
-#endif
-#ifdef IAEA
-        % For IAEA Conferences
-% same as NF except for MIN_NAMES and MAX_NAMES set to 1
-#   define ATIT_SUPPRESS 1
-#   define PAGE_START_J 1
-#   define PHYSICS_JOUR 1
-#   define EDIT_VAR 1
-#   define ATIT_LOWER 1
-#   define COMMA_DELIMIT 1
-#   define VOLUME_SPACE 1
-#   define MONTH_SUPPRESS 1
-#   define PAREN_DATE 1
-#   define NUM_SUPPRESS 1
-#   define BOLD_VOL 1
-#   define NAME_INVERT 1
-#   define NAME_UPPER 1
-#   define DATE_FIRST 1
-#   define MAX_NAMES 1
-#   define MIN_NAMES 1
-#   define JOUR_DEEMPH 1
-#endif
-#ifdef CPC
-        % For Computer Physics Communications
-% same as AIP except for NAME_INVERT, DATE_FIRST
-#   define ATIT_SUPPRESS 1
-#   define PAGE_START_J 1
-#   define PHYSICS_JOUR 1
-#   define MAX_NAMES 5
-#   define MIN_NAMES 1
-#   define EDIT_VAR 1
-#   define ATIT_LOWER 1
-#   define COMMA_DELIMIT 1
-#   define VOLUME_SPACE 1
-#   define MONTH_SUPPRESS 1
-#   define PAREN_DATE 1
-#   define NUM_SUPPRESS 1
-#   define BOLD_VOL 1
-#   define NAME_INVERT 1
-#   define DATE_FIRST 1
-#   define JOUR_DEEMPH 1
-#endif
-#ifdef RMP
-        % For Reviews of Modern Physics, 
-% except first name not inverted yet and order of fields not hacked
-#   define LAB_ALPH 1
-#   define SORTED 1
-#   define RMP_LABELS 1
-#   define ATIT_SUPPRESS 1
-#   define ATIT_LOWER 1
-#   define MONTH_SUPRESS 1
-#   define NUM_SUPPRESS 1
-#   define VOL_SUPPRESS 1
-#   define BOLD_VOL 1
-#   define BRACKET_NOTE 1
-#   define PAGE_START_J 1
-#   define PAGE_START_O 1
-#   define PAGE_ABBREV 1
-#   define PHYSICS_JOUR 1
-#   define COMMA_DELIMIT 1
-#   define EDIT_VAR 1
-#   define JOUR_DEEMPH 1
-#endif
-#ifdef REPORT
-        % For internal reports
-% same as AIP except for ATIT_SUPPRESS, MONTH_SUPPRESS, PAGE_START_J,
-% NUM_SUPPRESS, MAX_NAMES, MIN_NAMES
-#   define PHYSICS_JOUR 1
-#   define EDIT_VAR 1
-#   define ATIT_LOWER 0
-#   define COMMA_DELIMIT 1
-#   define VOLUME_SPACE 1
-#   define PAREN_DATE 1
-#   define BOLD_VOL 1
-#   define JOUR_DEEMPH 1
-#endif
-#ifdef APALIKE
-        % For American Psychological Association
-        % (same as ALPHA but with NAMED_REFS set and NAME_FULL unset)
-#   define LAB_ALPH 1
-#   define SORTED 1
-#   define NAME_FULL 0
-#   define ATIT_LOWER 1
-#   define MONTH_FULL 1
-#   define JOUR_FULL 1
-#   define NAMED_REFS 1
-#   define NAME_INVERT 1
-#endif
-#ifdef PPCF
-        % A physics version of APALIKE
-#   define PHYSICS_JOUR 1
-#   define LAB_ALPH 1
-#   define SORTED 1
-#   define NAME_FULL 0
-#   define ATIT_LOWER 0
-#   define ATIT_SUPPRESS 1
-#   define MONTH_FULL 1
-#   define JOUR_FULL 0
-#   define NAMED_REFS 1
-#   define NAME_INVERT 1
-#   define ETAL_EMPH 1
-#   define CSC_NAMES 1
-#   define NUM_SUPPRESS 1
-#   define BOLD_VOL 1
-#   define VOLUME_SPACE 1
-#endif
-
 % This is the start of btxbst.doc
-
 % BibTeX `plain' family
         % version 0.99b for BibTeX versions 0.99a or later, LaTeX version 2.09.
         % Copyright (C) 1985, all rights reserved.
@@ -258,45 +55,6 @@
         % btxbst.doc, plain.bst, unsrt.bst, alpha.bst, and abbrv.bst.
         % This restriction helps ensure that all standard styles are identical.
         % The file btxbst.doc has the documentation for this style.
-#if NAMED_REFS
-% BibTeX `apalike' bibliography style (24-Jan-88 version)
-% Adapted from the `alpha' style, version 0.99a; for BibTeX version 0.99a.
-% Copyright (C) 1988, all rights reserved.
-% Copying of this file is allowed, provided that if you make any changes at all
-% you name it something other than `apalike.bst'.
-% This restriction helps ensure that all copies are identical.
-% Differences between this style and `alpha' are generally heralded by a `%'.
-% The file btxbst.doc has the documentation for alpha.bst.
-%
-% This style should be used with the `apalike' LaTeX style (apalike.sty).
-% \cite's come out like "(Jones, 1986)" in the text but there are no labels
-% in the bibliography, and something like "(1986)" comes out immediately
-% after the author.  Author (and editor) names appear as last name, comma,
-% initials.  A `year' field is required for every entry, and so is either
-% an author (or in some cases, an editor) field or a key field.
-%
-% Editorial note:
-% Many journals require a style like `apalike', but I strongly, strongly,
-% strongly recommend that you not use it if you have a choice---use something
-% like `plain' instead.  Mary-Claire van Leunen (A Handbook for Scholars,
-% Knopf, 1979) argues convincingly that a style like `plain' encourages better
-% writing than one like `apalike'.  Furthermore the strongest arguments for
-% using an author-date style like `apalike'---that it's "the most practical"
-% (The Chicago Manual of Style, University of Chicago Press, thirteenth
-% edition, 1982, pages 400--401)---fall flat on their face with the new
-% computer-typesetting technology.  For instance page 401 anachronistically
-% states "The chief disadvantage of [a style like `plain'] is that additions
-% or deletions cannot be made after the manuscript is typed without changing
-% numbers in both text references and list."  LaTeX sidesteps the disadvantage.
-%
-% History:
-%   15-sep-86   (SK,OP) Original version, by Susan King and Oren Patashnik.
-%   10-nov-86   (OP)    Truncated the sort.key$ string to the correct length
-%                       in bib.sort.order to eliminate error message.
-%   24-jan-88   (OP)    Updated for BibTeX version 0.99a, from alpha.bst 0.99a;
-%                       apalike now sorts by author, then year, then title;
-%                       THIS `apalike' VERSION DOES NOT WORK WITH BIBTEX 0.98i.
-#endif APALIKE
 % Please notify Oren Patashnik (PATASHNIK@SCORE.STANFORD.EDU) of any bugs in
 % these standard styles or in this documentation file.
 %
@@ -304,27 +62,27 @@
 % and is also a template file that you can use to make
 % several different style files, if you have access to a C preprocessor.
 % For example, the standard styles were made by doing something like
-%       cpp -P -DPLAIN btxbst.doc plain.txt
-%       cpp -P -DUNSRT btxbst.doc unsrt.txt
-%       cpp -P -DALPHA btxbst.doc alpha.txt
-%       cpp -P -DABBRV btxbst.doc abbrv.txt
+% cpp -P -DPLAIN btxbst.doc plain.txt
+% cpp -P -DUNSRT btxbst.doc unsrt.txt
+% cpp -P -DALPHA btxbst.doc alpha.txt
+% cpp -P -DABBRV btxbst.doc abbrv.txt
 % and then renaming after removing unwanted comments and blank lines.
 % If you don't have access,
 % you can edit this file by hand to imitate the preprocessor,
 % with the following explanation of the C preprocessor constructs used here.
 %
 % The output of the preprocessor is the same as the input, except that certain
-% lines will be excluded (and some blank lines will be added).  The sequence
-%       #if VAR
-%           lines to be included when VAR is not zero
-%       #else
-%           lines to be included when VAR is zero
-%       #endif
+% lines will be excluded (and some blank lines will be added). The sequence
+% #if VAR
+% lines to be included when VAR is not zero
+% #else
+% lines to be included when VAR is zero
+% #endif
 % (with the #-signs appearing in column 1) means that one set or the other of
 % the lines are to be included depending on the value of VAR.
-% The #else part is optional.  Comments can be added after #else and #endif.
+% The #else part is optional. Comments can be added after #else and #endif.
 % Variables can be set by
-%       #define VAR value
+% #define VAR value
 % and one can also use #ifdef VAR to see if VAR has any value, and #ifndef
 % to see if it has none.
 % Another #if form used in this file is #if !VAR, which includes the lines
@@ -339,237 +97,178 @@
 % various lines that are chosen from the rest of the file.
 % Each boolean variable should be set true (1) or false (0) in each style.
 % Here are the current variables, and their meanings:
-%       LAB_ALPH:       an alphabetic label is used (if false then a numeric
-%                           label is used)
-%       SORTED:         the entries should be sorted by label (if nonnumeric)
-%                           and other info, like authors (if false, then
-%                           entries remain in order of occurrence)
-%       NAME_FULL:      the authors, editors, etc., get the full names as
-%                           given in the bibliography file (if false, the first
-%                           names become initials)
-%       ATIT_LOWER:     titles of non-"books" (e.g., articles) should be
-%                           converted to lower-case, except the first letter or
-%                           first letter after a colon
-%                           (if false then they appear as in the database)
-%       MONTH_FULL:     months are spelled out in full (if false, then
-%                           they're abbreviated)
-%       JOUR_FULL:      macro journal names are spelled out in full
-%                           (if false then they are abbreviated, currently
-%                           as they appear in ACM publications)
-#ifndef UNSRT
-#   ifndef ALPHA
-#       ifndef ABBRV
-%#          define PLAIN 1
-#       endif
-#   endif
-#endif
-#ifdef PLAIN
-% plain style (sorted numbers)
-#   define LAB_ALPH 0
-#   define SORTED 1
-#   define NAME_FULL 1
-#   define ATIT_LOWER 1
-#   define MONTH_FULL 1
-#   define JOUR_FULL 1
-#endif
-#ifdef UNSRT
-% unsrt style (unsorted numbers)
-#   define LAB_ALPH 0
-#   define SORTED 0
-#   define NAME_FULL 1
-#   define ATIT_LOWER 1
-#   define MONTH_FULL 1
-#   define JOUR_FULL 1
-#endif
-#ifdef ALPHA
-% alpha style (sorted short alphabetics)
-#   define LAB_ALPH 1
-#   define SORTED 1
-#   define NAME_FULL 1
-#   define ATIT_LOWER 1
-#   define MONTH_FULL 1
-#   define JOUR_FULL 1
-#endif
-#ifdef ABBRV
-% abbrv style (sorted numbers, with abbreviations)
-#   define LAB_ALPH 0
-#   define SORTED 1
-#   define NAME_FULL 0
-#   define ATIT_LOWER 1
-#   define MONTH_FULL 0
-#   define JOUR_FULL 0
-#endif
-%
-%   Entry formatting: Similar to that recommended by Mary-Claire van Leunen
-%       in "A Handbook for Scholars".  Book-like titles are italicized
-%       (emphasized) and non-book titles are converted to sentence
-%       capitilization (and not enclosed in quotes).
-%       This file outputs a \newblock between major blocks of an entry
-%       (the name \newblock is analogous to the names \newline and \newpage)
-%       so that the user can obtain an "open" format, which has a line break
-%       before each block and lines after the first are indented within blocks,
-%       by giving the optional \documentstyle argument `openbib';
-%       The default is the "closed" format---blocks runs together.
-%
-%   Citation alphabetic label format:
-%               [Knu73] for single author (or editor or key)
-%               [AHU83] (first letters of last names) for multiple authors
-%
-%   Citation label numberic format:
-%               [number]
-%
-%   Reference list ordering for sorted, alphabetic lables:
-%               alphabetical by citation label, then by author(s) or whatever
-%               passes for author in the absence of one, then by year,
-%               then title
-%
-%   Reference list ordering for sorted, numeric lables:
-%               alphabetical by author(s) or whatever passes
-%               for author in the absence of one, then by year, then title
-%
-%   Reference list ordering for unsorted:
-%               by the order cited in the text
-%
-%   History
-%   12/16/84    (HWT)   Original `plain' version, by Howard Trickey.
-%   12/23/84    (LL)    Some comments made by Leslie Lamport.
-%    2/16/85    (OP)    Changes based on LL's comments, Oren Patashnik.
-%    2/17/85    (HWT)   Template file and other standard styles made.
-%    3/28/85    (OP)    First release, version 0.98b for BibTeX 0.98f.
-%    5/ 9/85    (OP)    Version 0.98c for BibTeX 0.98i:
-%                       fixed Theoretical Computer Science macro name;
-%                       fixed the format.vol.num.pages function.
-%    1/24/88    (OP)    Version 0.99a for BibTeX 0.99a, main changes:
-%                       assignment operator (:=) arguments reversed;
-%                       the preamble$ function outputs the database PREAMBLE;
-%                       entry.max$ and global.max$ (built-in) variables replace
-%                       entry.string.max and global.string.max functions;
-%                       alphabetizing by year then title, not just title;
-%                       many unnecessary ties removed; \it ==> \em;
-%                       the `alpha' style uses a superscripted `+' instead of a
-%                       `*' for unnamed names in constructing the label;
-%                       the `abbrv' style now uses "Mar." and "Sept.";
-%                       the functions calc.label and presort now look at just
-%                       the fields they're supposed to;
-%                       BOOKLET, MASTERSTHESIS, TECHREPORT use nonbook titles;
-%                       INBOOK and INCOLLECTION take an optional type (e.g.
-%                       type = "Section"), overriding the default "chapter";
-%                       BOOK, INBOOK, INCOLLECTION, and PROCEEDINGS now allow
-%                       either volume or number, not just volume;
-%                       INCOLLECTION now allows an edition and series field;
-%                       PROCEEDINGS and INPROCEEDINGS now use the address field
-%                       to tell where a conference was held;
-%                       INPROCEEDINGS and PROCEEDINGS now allow either volume
-%                       or number, and also a series field;
-%                       MASTERSTHESIS and PHDTHESIS accept types other than
-%                       "Master's thesis" and "PhD thesis";
-%                       UNPUBLISHED now outputs, in one block, note then date;
-%                       MANUAL now prints out the organization in
-%                       the first block if the author field is empty;
-%                       MISC can't be empty---it requires some optional field.
-%    3/23/88    (OP)    Version 0.99b for BibTeX 0.99c---changed the three
-%                       erroneous occurrences of `cite ' to `cite$ '; this
-%                       change didn't affect the four standard styles, so the
-%                       0.99a versions of those styles are still current.
+% 0: an alphabetic label is used (if false then a numeric
+% label is used)
+% 0: the entries should be sorted by label (if nonnumeric)
+% and other info, like authors (if false, then
+% entries remain in order of occurrence)
+% 0: the authors, editors, etc., get the full names as
+% given in the bibliography file (if false, the first
+% names become initials)
+% 0: titles of non-"books" (e.g., articles) should be
+% converted to lower-case, except the first letter or
+% first letter after a colon
+% (if false then they appear as in the database)
+% 0: months are spelled out in full (if false, then
+% they're abbreviated)
+% 0: macro journal names are spelled out in full
+% (if false then they are abbreviated, currently
+% as they appear in ACM publications)
+%# define PLAIN 1
+%
+% Entry formatting: Similar to that recommended by Mary-Claire van Leunen
+% in "A Handbook for Scholars". Book-like titles are italicized
+% (emphasized) and non-book titles are converted to sentence
+% capitilization (and not enclosed in quotes).
+% This file outputs a \newblock between major blocks of an entry
+% (the name \newblock is analogous to the names \newline and \newpage)
+% so that the user can obtain an "open" format, which has a line break
+% before each block and lines after the first are indented within blocks,
+% by giving the optional \documentstyle argument `openbib';
+% The default is the "closed" format---blocks runs together.
+%
+% Citation alphabetic label format:
+% [Knu73] for single author (or editor or key)
+% [AHU83] (first letters of last names) for multiple authors
+%
+% Citation label numberic format:
+% [number]
+%
+% Reference list ordering for sorted, alphabetic lables:
+% alphabetical by citation label, then by author(s) or whatever
+% passes for author in the absence of one, then by year,
+% then title
+%
+% Reference list ordering for sorted, numeric lables:
+% alphabetical by author(s) or whatever passes
+% for author in the absence of one, then by year, then title
+%
+% Reference list ordering for unsorted:
+% by the order cited in the text
+%
+% History
+% 12/16/84 (HWT) Original `plain' version, by Howard Trickey.
+% 12/23/84 (LL) Some comments made by Leslie Lamport.
+% 2/16/85 (OP) Changes based on LL's comments, Oren Patashnik.
+% 2/17/85 (HWT) Template file and other standard styles made.
+% 3/28/85 (OP) First release, version 0.98b for BibTeX 0.98f.
+% 5/ 9/85 (OP) Version 0.98c for BibTeX 0.98i:
+% fixed Theoretical Computer Science macro name;
+% fixed the format.vol.num.pages function.
+% 1/24/88 (OP) Version 0.99a for BibTeX 0.99a, main changes:
+% assignment operator (:=) arguments reversed;
+% the preamble$ function outputs the database PREAMBLE;
+% entry.max$ and global.max$ (built-in) variables replace
+% entry.string.max and global.string.max functions;
+% alphabetizing by year then title, not just title;
+% many unnecessary ties removed; \it ==> \em;
+% the `alpha' style uses a superscripted `+' instead of a
+% `*' for unnamed names in constructing the label;
+% the `abbrv' style now uses "Mar." and "Sept.";
+% the functions calc.label and presort now look at just
+% the fields they're supposed to;
+% BOOKLET, MASTERSTHESIS, TECHREPORT use nonbook titles;
+% INBOOK and INCOLLECTION take an optional type (e.g.
+% type = "Section"), overriding the default "chapter";
+% BOOK, INBOOK, INCOLLECTION, and PROCEEDINGS now allow
+% either volume or number, not just volume;
+% INCOLLECTION now allows an edition and series field;
+% PROCEEDINGS and INPROCEEDINGS now use the address field
+% to tell where a conference was held;
+% INPROCEEDINGS and PROCEEDINGS now allow either volume
+% or number, and also a series field;
+% MASTERSTHESIS and PHDTHESIS accept types other than
+% "Master's thesis" and "PhD thesis";
+% UNPUBLISHED now outputs, in one block, note then date;
+% MANUAL now prints out the organization in
+% the first block if the author field is empty;
+% MISC can't be empty---it requires some optional field.
+% 3/23/88 (OP) Version 0.99b for BibTeX 0.99c---changed the three
+% erroneous occurrences of `cite ' to `cite$ '; this
+% change didn't affect the four standard styles, so the
+% 0.99a versions of those styles are still current.
 %
 % The ENTRY declaration
-%   Like Scribe's (according to pages 231-2 of the April '84 edition),
-%   but no fullauthor or editors fields because BibTeX does name handling.
-%   The annote field is commented out here because this family doesn't
-%   include an annotated bibliography style.  And in addition to the fields
-%   listed here, BibTeX has a built-in crossref field, explained later.
-
+% Like Scribe's (according to pages 231-2 of the April '84 edition),
+% but no fullauthor or editors fields because BibTeX does name handling.
+% The annote field is commented out here because this family doesn't
+% include an annotated bibliography style. And in addition to the fields
+% listed here, BibTeX has a built-in crossref field, explained later.
 ENTRY
 % Fields:
   { address
-%           Usually the address of a publisher or other type of organization.
-%           Put information in this field only if it helps the reader find the
-%           thing---for example you should omit the address of a major
-%           publisher entirely.  For a PROCEEDINGS or an INPROCEEDINGS,
-%           however, it's the address of the conference; for those two entry
-%           types, include the publisher's or organization's address, if
-%           necessary, in the publisher or organization field.
-%    annote
-%           Long annotation---for annotated bibliographies (begins sentence).
+% Usually the address of a publisher or other type of organization.
+% Put information in this field only if it helps the reader find the
+% thing---for example you should omit the address of a major
+% publisher entirely. For a PROCEEDINGS or an INPROCEEDINGS,
+% however, it's the address of the conference; for those two entry
+% types, include the publisher's or organization's address, if
+% necessary, in the publisher or organization field.
+% annote
+% Long annotation---for annotated bibliographies (begins sentence).
     author
-%           Name(s) of author(s), in BibTeX name format.
+% Name(s) of author(s), in BibTeX name format.
     booktitle
-%           Book title when the thing being referenced isn't the whole book.
-%           For book entries, the title field should be used instead.
+% Book title when the thing being referenced isn't the whole book.
+% For book entries, the title field should be used instead.
     chapter
-%           Chapter (or section or whatever) number.
+% Chapter (or section or whatever) number.
     edition
-%           Edition of a book---should be an ordinal (e.g., "Second").
+% Edition of a book---should be an ordinal (e.g., "Second").
     editor
-%           Name(s) of editor(s), in BibTeX name format.
-%           If there is also an author field, then the editor field should be
-%           for the book or collection that the work appears in.
+% Name(s) of editor(s), in BibTeX name format.
+% If there is also an author field, then the editor field should be
+% for the book or collection that the work appears in.
     howpublished
-%            How something strange has been published (begins sentence).
+% How something strange has been published (begins sentence).
     institution
-%           Sponsoring institution of a technical report.
+% Sponsoring institution of a technical report.
     journal
-%           Journal name (macros are provided for many).
+% Journal name (macros are provided for many).
     key
-%           Alphabetizing, labeling, and cross-referencing key
-%           (needed when an entry has no author or editor).
-#if !NAMED_REFS
+% Alphabetizing, labeling, and cross-referencing key
+% (needed when an entry has no author or editor).
     month
-#else NAMED_REFS
-%    month              not used in apalike
-#endif
-%           Month (macros are provided).
+% Month (macros are provided).
     note
-%           To help the reader find a reference (begins sentence).
+% To help the reader find a reference (begins sentence).
     number
-%           Number of a journal or technical report, or of a work in a series.
+% Number of a journal or technical report, or of a work in a series.
     organization
-%           Organization sponsoring a conference (or publishing a manual); if
-%           the editor (or author) is empty, and if the organization produces
-%           an awkward label or cross reference, you should put appropriately
-%           condensed organization information in the key field as well.
+% Organization sponsoring a conference (or publishing a manual); if
+% the editor (or author) is empty, and if the organization produces
+% an awkward label or cross reference, you should put appropriately
+% condensed organization information in the key field as well.
     pages
-%           Page number or numbers (use `--' to separate a range, use `+'
-%           to indicate pages following that don't form a simple range).
+% Page number or numbers (use `--' to separate a range, use `+'
+% to indicate pages following that don't form a simple range).
     publisher
-%           Publisher name.
+% Publisher name.
     school
-%           School name (for theses).
+% School name (for theses).
     series
-%           The name of a series or set of books.
-%           An individual book will will also have it's own title.
+% The name of a series or set of books.
+% An individual book will will also have it's own title.
     title
-%           The title of the thing you're referred to.
+% The title of the thing you're referred to.
     type
-%           Type of a Techreport (e.g., "Research Note") to be used instead of
-%           the default "Technical Report"; or, similarly, the type of a
-%           thesis; or of a part of a book.
+% Type of a Techreport (e.g., "Research Note") to be used instead of
+% the default "Technical Report"; or, similarly, the type of a
+% thesis; or of a part of a book.
     volume
-%           The volume number of a journal or multivolume work.
+% The volume number of a journal or multivolume work.
     year
-%           The year should contain only numerals (technically, it should end
-%           with four numerals, after purification; doesn't a begin sentence).
+% The year should contain only numerals (technically, it should end
+% with four numerals, after purification; doesn't a begin sentence).
   }
 % There are no integer entry variables
   {}
 % These string entry variables are used to form the citation label.
 % In a storage pinch, sort.label can be easily computed on the fly.
-#if LAB_ALPH
-#if SORTED
-  { label extra.label sort.label }
-#else !SORTED
-% It doesn't seem like a good idea to use an order-of-citation
-% reference list when using alphabetic labels, but when this happens
-% we do things a little differently
   { label }
-#endif SORTED
-#else !LAB_ALPH
-  { label }
-#endif LAB_ALPH
-
 % Each entry function starts by calling output.bibitem, to write the
-% \bibitem and its arguments to the .BBL file.  Then the various fields
-% are formatted and printed by output or output.check.  Those functions
+% \bibitem and its arguments to the .BBL file. Then the various fields
+% are formatted and printed by output or output.check. Those functions
 % handle the writing of separators (commas, periods, \newblock's),
 % taking care not to do so when they are passed a null string.
 % Finally, fin.entry is called to add the final period and finish the
@@ -577,12 +276,12 @@
 %
 % A bibliographic reference is formatted into a number of `blocks':
 % in the open format, a block begins on a new line and subsequent
-% lines of the block are indented.  A block may contain more than
+% lines of the block are indented. A block may contain more than
 % one sentence (well, not a grammatical sentence, but something to
-% be ended with a sentence ending period).  The entry functions should
+% be ended with a sentence ending period). The entry functions should
 % call new.block whenever a block other than the first is about to be
-% started.  They should call new.sentence whenever a new sentence is
-% to be started.  The output functions will ensure that if two
+% started. They should call new.sentence whenever a new sentence is
+% to be started. The output functions will ensure that if two
 % new.sentence's occur without any non-null string being output between
 % them then there won't be two periods output.  Similarly for two
 % successive new.block's.
@@ -590,57 +289,57 @@
 % The output routines don't write their argument immediately.
 % Instead, by convention, that argument is saved on the stack to be
 % output next time (when we'll know what separator needs to come
-% after it).  Meanwhile, the output routine has to pop the pending
+% after it). Meanwhile, the output routine has to pop the pending
 % output off the stack, append any needed separator, and write it.
 %
 % To tell which separator is needed, we maintain an output.state.
 % It will be one of these values:
-%       before.all              just after the \bibitem
-%       mid.sentence            in the middle of a sentence: comma needed
-%                                       if more sentence is output
-%       after.sentence          just after a sentence: period needed
-%       after.block             just after a block (and sentence):
-%                                       period and \newblock needed.
+% before.all just after the \bibitem
+% mid.sentence in the middle of a sentence: comma needed
+% if more sentence is output
+% after.sentence just after a sentence: period needed
+% after.block just after a block (and sentence):
+% period and \newblock needed.
 % Note: These styles don't use after.sentence
 %
-% VAR: output.state : INTEGER           -- state variable for output
+% VAR: output.state : INTEGER -- state variable for output
 %
 % The output.nonnull function saves its argument (assumed to be nonnull)
 % on the stack, and writes the old saved value followed by any needed
-% separator.  The ordering of the tests is decreasing frequency of
+% separator. The ordering of the tests is decreasing frequency of
 % occurrence.
 %
 % output.nonnull(s) ==
-%  BEGIN
-%       s := argument on stack
-%       if output.state = mid.sentence then
-%           write$(pop() * ", ")
-%                 -- "pop" isn't a function: just use stack top
-%       else
-%           if output.state = after.block then
-%               write$(add.period$(pop()))
-%               newline$
-%               write$("\newblock ")
-%           else
-%               if output.state = before.all then
-%                   write$(pop())
-%               else        -- output.state should be after.sentence
-%                   write$(add.period$(pop()) * " ")
-%               fi
-%           fi
-%           output.state := mid.sentence
-%       fi
-%       push s on stack
-%  END
+% BEGIN
+% s := argument on stack
+% if output.state = mid.sentence then
+% write$(pop() * ", ")
+% -- "pop" isn't a function: just use stack top
+% else
+% if output.state = after.block then
+% write$(add.period$(pop()))
+% newline$
+% write$("\newblock ")
+% else
+% if output.state = before.all then
+% write$(pop())
+% else -- output.state should be after.sentence
+% write$(add.period$(pop()) * " ")
+% fi
+% fi
+% output.state := mid.sentence
+% fi
+% push s on stack
+% END
 %
 % The output function calls output.nonnull if its argument is non-empty;
 % its argument may be a missing field (thus, not necessarily a string)
 %
 % output(s) ==
-%  BEGIN
-%       if not empty$(s) then output.nonnull(s)
-%       fi
-%  END
+% BEGIN
+% if not empty$(s) then output.nonnull(s)
+% fi
+% END
 %
 % The output.check function is the same as the output function except that, if
 % necessary, output.check warns the user that the t field shouldn't be empty
@@ -649,86 +348,74 @@
 % such fields are empty).
 %
 % output.check(s,t) ==
-%  BEGIN
-%       if empty$(s) then
-%           warning$("empty " * t * " in " * cite$)
-%       else output.nonnull(s)
-%       fi
-%  END
+% BEGIN
+% if empty$(s) then
+% warning$("empty " * t * " in " * cite$)
+% else output.nonnull(s)
+% fi
+% END
 %
 % The output.bibitem function writes the \bibitem for the current entry
 % (the label should already have been set up), and sets up the separator
-% state for the output functions.  And, it leaves a string on the stack
+% state for the output functions. And, it leaves a string on the stack
 % as per the output convention.
 %
 % output.bibitem ==
-%  BEGIN
-%       newline$
-%       write$("\bibitem[")     % for alphabetic labels,
-%       write$(label)           % these three lines
-%       write$("]{")            % are used
-%       write$("\bibitem{")             % this line for numeric labels
-%       write$(cite$)
-%       write$("}")
-%       push "" on stack
-%       output.state := before.all
-%  END
+% BEGIN
+% newline$
+% write$("\bibitem[") % for alphabetic labels,
+% write$(label) % these three lines
+% write$("]{") % are used
+% write$("\bibitem{") % this line for numeric labels
+% write$(cite$)
+% write$("}")
+% push "" on stack
+% output.state := before.all
+% END
 %
 % The fin.entry function finishes off an entry by adding a period to the
-% string remaining on the stack.  If the state is still before.all
+% string remaining on the stack. If the state is still before.all
 % then nothing was produced for this entry, so the result will look bad,
 % but the user deserves it. (We don't omit the whole entry because the
 % entry was cited, and a bibitem is needed to define the citation label.)
 %
 % fin.entry ==
-%  BEGIN
-%       write$(add.period$(pop()))
-%       newline$
-%  END
+% BEGIN
+% write$(add.period$(pop()))
+% newline$
+% END
 %
 % The new.block function prepares for a new block to be output, and
 % new.sentence prepares for a new sentence.
 %
 % new.block ==
-%  BEGIN
-%       if output.state <> before.all then
-%           output.state := after.block
-%       fi
-%  END
+% BEGIN
+% if output.state <> before.all then
+% output.state := after.block
+% fi
+% END
 %
 % new.sentence ==
-%  BEGIN
-%       if output.state <> after.block then
-%           if output.state <> before.all then
-%               output.state :=  after.sentence
-%           fi
-%       fi
-%  END
+% BEGIN
+% if output.state <> after.block then
+% if output.state <> before.all then
+% output.state := after.sentence
+% fi
+% fi
+% END
 %
-
 INTEGERS { output.state before.all mid.sentence after.sentence after.block }
-
 FUNCTION {init.state.consts}
 { #0 'before.all :=
-  #1 'mid.sentence :=
-  #2 'after.sentence :=
-  #3 'after.block :=
 }
-
 % the variables s and t are temporary string holders
-
 STRINGS { s t }
-
 FUNCTION {output.nonnull}
 { 's :=
   output.state mid.sentence =
     { ", " * write$ }
     { output.state after.block =
-#if !COMMA_DELIMIT
         { add.period$ write$
-#else COMMA_DELIMIT
-        { "," * write$
-#endif
           newline$
           "\newblock " write$
         }
@@ -743,14 +430,12 @@
   if$
   s
 }
-
 FUNCTION {output}
 { duplicate$ empty$
     'pop$
     'output.nonnull
   if$
 }
-
 FUNCTION {output.check}
 { 't :=
   duplicate$ empty$
@@ -758,55 +443,28 @@
     'output.nonnull
   if$
 }
-
-#if NAMED_REFS
-%                                       apalike needs this function because
-%                                       the year has special punctuation;
-%                                       apalike ignores the month
-FUNCTION {output.year.check}
-{ year empty$
-    { "empty year in " cite$ * warning$ }
-    { write$
-      " (" year * extra.label * ")" *
-      mid.sentence 'output.state :=
-    }
-  if$
-}
-#endif NAMED_REFS
-
 FUNCTION {output.bibitem}
 { newline$
-#if LAB_ALPH
-  "\bibitem[" write$
-  label write$
-  "]{" write$
-#else
   "\bibitem{" write$
-#endif LAB_ALPH
   cite$ write$
   "}" write$
   newline$
   ""
   before.all 'output.state :=
 }
-
 % This function finishes all entries.
-
 FUNCTION {fin.entry}
 { add.period$
   write$
   newline$
 }
-
 FUNCTION {new.block}
 { output.state before.all =
     'skip$
     { after.block 'output.state := }
   if$
 }
-
 FUNCTION {new.sentence}
-#if !COMMA_DELIMIT
 { output.state after.block =
     'skip$
     { output.state before.all =
@@ -815,47 +473,35 @@
       if$
     }
   if$
-#else COMMA_DELIMIT
-{ skip$
-#endif
 }
-
 % These three functions pop one or two (integer) arguments from the stack
 % and push a single one, either 0 or 1.
 % The 'skip$ in the `and' and `or' functions are used because
 % the corresponding if$ would be idempotent
-
 FUNCTION {not}
-{   { #0 }
+{ { #0 }
     { #1 }
   if$
 }
-
 FUNCTION {and}
-{   'skip$
+{ 'skip$
     { pop$ #0 }
   if$
 }
-
 FUNCTION {or}
-{   { pop$ #1 }
+{ { pop$ #1 }
     'skip$
   if$
 }
-
-% Sometimes we begin a new block only if the block will be big enough.  The
+% Sometimes we begin a new block only if the block will be big enough. The
 % new.block.checka function issues a new.block if its argument is nonempty;
 % new.block.checkb does the same if either of its TWO arguments is nonempty.
-
-#if !NAMED_REFS
 FUNCTION {new.block.checka}
 { empty$
     'skip$
     'new.block
   if$
 }
-#endif !NAMED_REFS
-
 FUNCTION {new.block.checkb}
 { empty$
   swap$ empty$
@@ -864,17 +510,13 @@
     'new.block
   if$
 }
-
-#if !NAMED_REFS
 % The new.sentence.check functions are analogous.
-
 FUNCTION {new.sentence.checka}
 { empty$
     'skip$
     'new.sentence
   if$
 }
-
 FUNCTION {new.sentence.checkb}
 { empty$
   swap$ empty$
@@ -883,8 +525,6 @@
     'new.sentence
   if$
 }
-#endif !NAMED_REFS
-
 % Here are some functions for formatting chunks of an entry.
 % By convention they either produce a string that can be followed by
 % a comma or period (using add.period$, so it is OK to end in a period),
@@ -899,220 +539,120 @@
 % stack is a string rather than a missing field.
 %
 % field.or.null(s) ==
-%  BEGIN
-%       if empty$(s) then return ""
-%       else return s
-%  END
+% BEGIN
+% if empty$(s) then return ""
+% else return s
+% END
 %
 % Another helper function is emphasize, which returns the argument emphazised,
-% if that is non-empty, otherwise it returns the null string.  Italic
+% if that is non-empty, otherwise it returns the null string. Italic
 % corrections aren't used, so this function should be used when punctation
 % will follow the result.
 %
 % emphasize(s) ==
-%  BEGIN
-%       if empty$(s) then return ""
-%       else return "{\em " * s * "}"
+% BEGIN
+% if empty$(s) then return ""
+% else return "{\em " * s * "}"
 %
 % The format.names function formats the argument (which should be in
 % BibTeX name format) into "First Von Last, Junior", separated by commas
 % and with an "and" before the last (but ending with "et~al." if the last
-% of multiple authors is "others").  This function's argument should always
+% of multiple authors is "others"). This function's argument should always
 % contain at least one name.
 %
 % VAR: nameptr, namesleft, numnames: INTEGER
-% pseudoVAR: nameresult: STRING         (it's what's accumulated on the stack)
+% pseudoVAR: nameresult: STRING (it's what's accumulated on the stack)
 %
 % format.names(s) ==
-%  BEGIN
-%       nameptr := 1
-%       numnames := num.names$(s)
-%       namesleft := numnames
-%       while namesleft > 0
-%         do
-%                               % for full names:
-%           t := format.name$(s, nameptr, "{ff~}{vv~}{ll}{, jj}")
-%                               % for abbreviated first names:
-%           t := format.name$(s, nameptr, "{f.~}{vv~}{ll}{, jj}")
-%           if nameptr > 1 then
-%               if namesleft > 1 then nameresult := nameresult * ", " * t
-%               else if numnames > 2
-%                      then nameresult := nameresult * ","
-%                    fi
-%                    if t = "others"
-%                      then nameresult := nameresult * " et~al."
-%                      else nameresult := nameresult * " and " * t
-%                    fi
-%               fi
-%           else nameresult := t
-%           fi
-%           nameptr := nameptr + 1
-%           namesleft := namesleft - 1
-%         od
-%       return nameresult
-%  END
+% BEGIN
+% nameptr := 1
+% numnames := num.names$(s)
+% namesleft := numnames
+% while namesleft > 0
+% do
+% % for full names:
+% t := format.name$(s, nameptr, "{ff~}{vv~}{ll}{, jj}")
+% % for abbreviated first names:
+% t := format.name$(s, nameptr, "{f.~}{vv~}{ll}{, jj}")
+% if nameptr > 1 then
+% if namesleft > 1 then nameresult := nameresult * ", " * t
+% else if numnames > 2
+% then nameresult := nameresult * ","
+% fi
+% if t = "others"
+% then nameresult := nameresult * " et~al."
+% else nameresult := nameresult * " and " * t
+% fi
+% fi
+% else nameresult := t
+% fi
+% nameptr := nameptr + 1
+% namesleft := namesleft - 1
+% od
+% return nameresult
+% END
 %
 % The format.authors function returns the result of format.names(author)
 % if the author is present, or else it returns the null string
 %
 % format.authors ==
-%  BEGIN
-%       if empty$(author) then return ""
-%       else return format.names(author)
-%       fi
-%  END
+% BEGIN
+% if empty$(author) then return ""
+% else return format.names(author)
+% fi
+% END
 %
 % Format.editors is like format.authors, but it uses the editor field,
 % and appends ", editor" or ", editors"
 %
 % format.editors ==
-%  BEGIN
-%       if empty$(editor) then return ""
-%       else
-%           if num.names$(editor) > 1 then
-%               return format.names(editor) * ", editors"
-%           else
-%               return format.names(editor) * ", editor"
-%           fi
-%       fi
-%  END
+% BEGIN
+% if empty$(editor) then return ""
+% else
+% if num.names$(editor) > 1 then
+% return format.names(editor) * ", editors"
+% else
+% return format.names(editor) * ", editor"
+% fi
+% fi
+% END
 %
 % Other formatting functions are similar, so no "comment version" will be
 % given for them.
 %
 % The `pop$' in this function gets rid of the duplicate `empty' value and
 % the `skip$' returns the duplicate field value
-
 FUNCTION {field.or.null}
 { duplicate$ empty$
     { pop$ "" }
     'skip$
   if$
 }
-
 FUNCTION {emphasize}
 { duplicate$ empty$
     { pop$ "" }
     { "{\em " swap$ * "}" * }
   if$
 }
-
-#if CSC_NAMES
-FUNCTION {caps}
-{ duplicate$ empty$
-    { pop$ "" }
-    { "{\sc " swap$ * "}" * }
-  if$
-}
-#endif
-
-#if BOLD_VOL
-FUNCTION {embolden}
-{ duplicate$ empty$
-    { pop$ "" }
-    { "{\bf " swap$ * "}" * }
-  if$
-}
-#endif
-
-#if BRACKET_NOTE
-FUNCTION {bracket}
-{ duplicate$ empty$
-    { pop$ "" }
-    { "[" swap$ * "]" * }
-  if$
-}
-#endif
-
-#if PAREN_DATE
-FUNCTION {paren}
-{ duplicate$ empty$
-    { pop$ "" }
-    { "(" swap$ * ")" * }
-  if$
-}
-#endif
-
 INTEGERS { nameptr namesleft numnames }
-
-#if MAX_NAMES
-INTEGERS { etal }
-#endif
-
 FUNCTION {format.names}
 { 's :=
-  #1 'nameptr :=
   s num.names$ 'numnames :=
-#if !MAX_NAMES
   numnames 'namesleft :=
-#else MAX_NAMES
-  numnames #MAX_NAMES >
-  s numnames "{ll}" format.name$ "others" = numnames #MIN_NAMES > and
-  or 'etal :=
-  etal
-    { #MIN_NAMES #1 + 'namesleft := }
-    { numnames 'namesleft := }
-  if$
-#endif
     { namesleft #0 > }
-#if NAME_FULL
-#if !NAME_INVERT
-    { s nameptr "{ff~}{vv~}{ll}{, jj}" format.name$ 't :=
-#else NAME_INVERT
-    { s nameptr "{vv~}{ll}{, jj}{, ff}" format.name$ 't :=
-#endif
-#else
-#if !NAME_INVERT
     { s nameptr "{f.~}{vv~}{ll}{, jj}" format.name$ 't :=
-#else NAME_INVERT
-    { s nameptr "{vv~}{ll}{, jj}{, f.}" format.name$ 't :=   % last name first
-#endif
-#endif NAME_FULL
-#if NAME_UPPER
-      t "others" =
-        'skip$
-        { t "u" change.case$ 't := }
-      if$
-#endif
-#if CSC_NAMES
-      t "others" =
-        'skip$
-        { t caps 't := }
-      if$
-#endif
       nameptr #1 >
         { namesleft #1 >
             { ", " * t * }
-#if !MAX_NAMES
             { numnames #2 >
                 { "," * }
                 'skip$
               if$
               t "others" =
-#if !ETAL_EMPH
-                { " et~al." * }
-#else ETAL_EMPH
-                { " {\em et~al.}" * }
-#endif ETAL_EMPH
-                { " and " * t * }
-              if$
-            }
-#else MAX_NAMES
-            { nameptr #2 >
-                { "," * }
-                'skip$
-              if$
-              t "others" =
-              etal or
-#if !ETAL_EMPH
                 { " et~al." * }
-#else ETAL_EMPH
-                { " {\em et~al.}" * }
-#endif ETAL_EMPH
                 { " and " * t * }
               if$
             }
-#endif
           if$
         }
         't
@@ -1122,23 +662,12 @@
     }
   while$
 }
-
 FUNCTION {format.authors}
 { author empty$
     { "" }
     { author format.names }
   if$
 }
-
-#if NAMED_REFS
-FUNCTION {format.key}                   % this function is just for apalike
-{ empty$
-    { key field.or.null }
-    { "" }
-  if$
-}
-#endif NAMED_REFS
-
 FUNCTION {format.editors}
 { editor empty$
     { "" }
@@ -1150,71 +679,53 @@
     }
   if$
 }
-
-#if EDIT_VAR
-FUNCTION {format.edited}
-{ editor empty$
-    { "" }
-    { "edited by " editor format.names * }
-  if$
-}
-#endif
-
 % The format.title function is used for non-book-like titles.
 % For most styles we convert to lowercase (except for the very first letter,
 % and except for the first one after a colon (followed by whitespace)),
 % and hope the user has brace-surrounded words that need to stay capitilized;
 % for some styles, however, we leave it as it is in the database.
-
 FUNCTION {format.title}
 { title empty$
     { "" }
-#if ATIT_LOWER
-    { title "t" change.case$ }
-#else
     'title
-#endif ATIT_LOWER
   if$
 }
-
 % By default, BibTeX sets the global integer variable global.max$ to the BibTeX
 % constant glob_str_size, the maximum length of a global string variable.
 % Analogously, BibTeX sets the global integer variable entry.max$ to
 % ent_str_size, the maximum length of an entry string variable.
 % The style designer may change these if necessary (but this is unlikely)
-
 % The n.dashify function makes each single `-' in a string a double `--'
 % if it's not already
 %
-% pseudoVAR: pageresult: STRING         (it's what's accumulated on the stack)
+% pseudoVAR: pageresult: STRING (it's what's accumulated on the stack)
 %
 % n.dashify(s) ==
-%  BEGIN
-%       t := s
-%       pageresult := ""
-%       while (not empty$(t))
-%         do
-%           if (first character of t = "-")
-%             then
-%               if (next character isn't)
-%                 then
-%                   pageresult := pageresult * "--"
-%                   t := t with the "-" removed
-%                 else
-%                   while (first character of t = "-")
-%                     do
-%                       pageresult := pageresult * "-"
-%                       t := t with the "-" removed
-%                     od
-%               fi
-%             else
-%               pageresult := pageresult * the first character
-%               t := t with the first character removed
-%           fi
-%         od
-%       return pageresult
-%  END
-
+% BEGIN
+% t := s
+% pageresult := ""
+% while (not empty$(t))
+% do
+% if (first character of t = "-")
+% then
+% if (next character isn't)
+% then
+% pageresult := pageresult * "--"
+% t := t with the "-" removed
+% else
+% while (first character of t = "-")
+% do
+% pageresult := pageresult * "-"
+% t := t with the "-" removed
+% od
+% fi
+% else
+% pageresult := pageresult * the first character
+% t := t with the first character removed
+% fi
+% od
+% return pageresult
+% END
 FUNCTION {n.dashify}
 { 't :=
   ""
@@ -1224,7 +735,7 @@
             { "--" *
               t #2 global.max$ substring$ 't :=
             }
-            {   { t #1 #1 substring$ "-" = }
+            { { t #1 #1 substring$ "-" = }
                 { "-" *
                   t #2 global.max$ substring$ 't :=
                 }
@@ -1239,35 +750,11 @@
     }
   while$
 }
-
-#define TEMP 0
-#if PAGE_START_J
-#define TEMP 1
-#endif
-#if PAGE_START_O
-#define TEMP 1
-#endif
-
-#if TEMP
-FUNCTION {first.page}
-{ 't :=
-  ""
-    {  t empty$ not t #1 #1 substring$ "-" = not and }
-    { t #1 #1 substring$ *
-      t #2 global.max$ substring$ 't :=
-    }
-  while$
-}
-#endif
-
-#if !NAMED_REFS
 % The format.date function is for the month and year, but we give a warning if
 % there's an empty year but the month is there, and we return the empty string
 % if they're both empty.
-
 FUNCTION {format.date}
 { year empty$
-#if !MONTH_SUPPRESS
     { month empty$
         { "" }
         { "there's a month but no year in " cite$ * warning$
@@ -1280,34 +767,25 @@
         { month " " * year * }
       if$
     }
-#else MONTH_SUPPRESS
-    { "" }
-    'year
-#endif
   if$
 }
-#endif !NAMED_REFS
-
 % The format.btitle is for formatting the title field when it is a book-like
 % entry---the style used here keeps it in uppers-and-lowers and emphasizes it.
-
 FUNCTION {format.btitle}
 { title emphasize
 }
-
 % For several functions we'll need to connect two strings with a
 % tie (~) if the second one isn't very long (fewer than 3 characters).
-% The tie.or.space.connect function does that.  It concatenates the two
+% The tie.or.space.connect function does that. It concatenates the two
 % strings on top of the stack, along with either a tie or space between
 % them, and puts this concatenation back onto the stack:
 %
 % tie.or.space.connect(str1,str2) ==
-%    BEGIN
-%       if text.length$(str2) < 3
-%         then return the concatenation of str1, "~", and str2
-%         else return the concatenation of str1, " ", and str2
-%    END
-
+% BEGIN
+% if text.length$(str2) < 3
+% then return the concatenation of str1, "~", and str2
+% else return the concatenation of str1, " ", and str2
+% END
 FUNCTION {tie.or.space.connect}
 { duplicate$ text.length$ #3 <
     { "~" }
@@ -1315,30 +793,26 @@
   if$
   swap$ * *
 }
-
 % The either.or.check function complains if both fields or an either-or pair
 % are nonempty.
 %
 % either.or.check(t,s) ==
-%  BEGIN
-%       if empty$(s) then
-%           warning$(can't use both " * t * " fields in " * cite$)
-%       fi
-%  END
-
+% BEGIN
+% if empty$(s) then
+% warning$(can't use both " * t * " fields in " * cite$)
+% fi
+% END
 FUNCTION {either.or.check}
 { empty$
     'pop$
     { "can't use both " swap$ * " fields in " * cite$ * warning$ }
   if$
 }
-
 % The format.bvolume function is for formatting the volume and perhaps
-% series name of a multivolume work.  If both a volume and a series field
+% series name of a multivolume work. If both a volume and a series field
 % are there, we assume the series field is the title of the whole multivolume
 % work (the title field should be the title of the thing being referred to),
-% and we add an "of <series>".  This function is called in mid-sentence.
-
+% and we add an "of <series>". This function is called in mid-sentence.
 FUNCTION {format.bvolume}
 { volume empty$
     { "" }
@@ -1351,17 +825,15 @@
     }
   if$
 }
-
 % The format.number.series function is for formatting the series name
-% and perhaps number of a work in a series.  This function is similar to
+% and perhaps number of a work in a series. This function is similar to
 % format.bvolume, although for this one the series must exist (and the
-% volume must not exist).  If the number field is empty we output either
+% volume must not exist). If the number field is empty we output either
 % the series field unchanged if it exists or else the null string.
 % If both the number and series fields are there we assume the series field
 % gives the name of the whole series (the title field should be the title
 % of the work being one referred to), and we add an "in <series>".
 % We capitilize Number when this function is used at the beginning of a block.
-
 FUNCTION {format.number.series}
 { volume empty$
     { number empty$
@@ -1381,11 +853,9 @@
     { "" }
   if$
 }
-
 % The format.edition function appends " edition" to the edition, if present.
 % We lowercase the edition (it should be something like "Third"), because
 % this doesn't start a sentence.
-
 FUNCTION {format.edition}
 { edition empty$
     { "" }
@@ -1396,7 +866,6 @@
     }
   if$
 }
-
 % The format.pages function is used for formatting a page range in a book
 % (and in rare circumstances, an article).
 %
@@ -1404,27 +873,24 @@
 % so that format.pages can use "page" instead of "pages" if none exists.
 % Note: global.max$ here means "take the rest of the string"
 %
-% VAR: multiresult: INTEGER     (actually, a boolean)
+% VAR: multiresult: INTEGER (actually, a boolean)
 %
 % multi.page.check(s) ==
-%  BEGIN
-%       t := s
-%       multiresult := false
-%       while ((not multiresult) and (not empty$(t)))
-%         do
-%           if (first character of t = "-" or "," or "+")
-%             then multiresult := true
-%             else t := t with the first character removed
-%           fi
-%         od
-%       return multiresult
-%  END
-
+% BEGIN
+% t := s
+% multiresult := false
+% while ((not multiresult) and (not empty$(t)))
+% do
+% if (first character of t = "-" or "," or "+")
+% then multiresult := true
+% else t := t with the first character removed
+% fi
+% od
+% return multiresult
+% END
 INTEGERS { multiresult }
-
 FUNCTION {multi.page.check}
 { 't :=
-  #0 'multiresult :=
     { multiresult not
       t empty$ not
       and
@@ -1441,53 +907,23 @@
   while$
   multiresult
 }
-
 % This function doesn't begin a sentence so "pages" isn't capitalized.
 % Other functions that use this should keep that in mind.
-
 FUNCTION {format.pages}
 { pages empty$
     { "" }
     { pages multi.page.check
-#if !PAGE_ABBREV
         { "pages" pages n.dashify tie.or.space.connect }
         { "page" pages tie.or.space.connect }
-#else PAGE_ABBREV
-        { "pp." pages n.dashify tie.or.space.connect }
-        { "p." pages tie.or.space.connect }
-#endif
       if$
     }
   if$
 }
-
-#if TEMP
-FUNCTION {format.pages.a}
-{ pages empty$
-    { "" }
-#if !PAGE_ABBREV
-    { "page" pages first.page tie.or.space.connect }
-#else PAGE_ABBREV
-    { "p." pages first.page tie.or.space.connect }
-#endif
-  if$
-}
-#endif
-
 % The format.vol.num.pages function is for the volume, number, and page range
-% of a journal article.  We use the format:  vol(number):pages, with some
-% variations for empty fields.  This doesn't begin a sentence.
-
+% of a journal article. We use the format: vol(number):pages, with some
+% variations for empty fields. This doesn't begin a sentence.
 FUNCTION {format.vol.num.pages}
-#if !BOLD_VOL
 { volume field.or.null
-#else BOLD_VOL
-{ volume field.or.null embolden
-#endif
-#if VOLUME_SPACE
-  " " swap$ * *
-#endif
-#if !NUM_SUPPRESS
   number empty$
     'skip$
     { "(" number * ")" * *
@@ -1497,56 +933,18 @@
       if$
     }
   if$
-#endif
-#if DATE_FIRST
-  format.date empty$
-    'skip$
-    { duplicate$ empty$
-        { pop$ format.date paren }
-        { " " * format.date paren * }
-      if$
-    }
-  if$
-#endif
   pages empty$
     'skip$
     { duplicate$ empty$
-#if !PAGE_START_J
         { pop$ format.pages }
-#else PAGE_START_J
-        { pop$ format.pages.a }
-#endif
-#if !PAGE_START_J
-#if !DATE_FIRST
-#if !VOLUME_SPACE
         { ":" * pages n.dashify * }
-#else VOLUME_SPACE
-        { ", " * pages n.dashify * }
-#endif
-#else DATE_FIRST
-        { " " * pages n.dashify *}
-#endif
-#else PAGE_START_J
-#if !DATE_FIRST
-#if !VOLUME_SPACE
-        { ":" * pages first.page * }
-#else VOLUME_SPACE
-        { ", " * pages first.page * }
-#endif
-#else DATE_FIRST
-        { " " * pages first.page *}
-#endif
-#endif
       if$
     }
   if$
 }
-
-
 % The format.chapter.pages, if the chapter is present, puts whatever is in the
 % type field (or else "chapter" if type is empty) in front of a chapter number.
-% It then appends the pages, if present.  This doesn't begin a sentence.
-
+% It then appends the pages, if present. This doesn't begin a sentence.
 FUNCTION {format.chapter.pages}
 { chapter empty$
     'format.pages
@@ -1562,60 +960,32 @@
     }
   if$
 }
-
 % The format.in.ed.booktitle function is used for starting out a sentence
 % that begins "In <booktitle>", putting an editor before the title if one
 % exists.
-
 FUNCTION {format.in.ed.booktitle}
 { booktitle empty$
     { "" }
     { editor empty$
-#if !COMMA_DELIMIT
         { "In " booktitle emphasize * }
-#if !EDIT_VAR
         { "In " format.editors * ", " * booktitle emphasize * }
-#else EDIT_VAR
-        { "In " booktitle emphasize * ", " * format.edited * }
-#endif
-#else COMMA_DELIMIT
-        { "in " booktitle emphasize * }
-#if !EDIT_VAR
-        { "in " format.editors * ", " * booktitle emphasize * }
-#else EDIT_VAR
-        { "in " booktitle emphasize * ", " * format.edited * }
-#endif
-#endif
       if$
     }
   if$
 }
-
-#if !NAMED_REFS
 % The function empty.misc.check complains if all six fields are empty, and
 % if there's been no sorting or alphabetic-label complaint.
-
 FUNCTION {empty.misc.check}
 { author empty$ title empty$ howpublished empty$
   month empty$ year empty$ note empty$
   and and and and and
-#if SORTED
-  key empty$ not and
-#else !SORTED
-#if LAB_ALPH
-  key empty$ not and
-#endif LAB_ALPH
-#endif SORTED
     { "all relevant fields are empty in " cite$ * warning$ }
     'skip$
   if$
 }
-#endif
-
 % The function format.thesis.type returns either the (case-changed) type field,
 % if it is defined, or else the default string already on the stack
 % (like "Master's thesis" or "PhD thesis").
-
 FUNCTION {format.thesis.type}
 { type empty$
     'skip$
@@ -1624,12 +994,10 @@
     }
   if$
 }
-
 % The function format.tr.number makes a string starting with "Technical Report"
 % (or type, if that field is defined), followed by the number if there is one;
 % it returns the starting part (with a case change) even if there is no number.
 % This is used at the beginning of a sentence.
-
 FUNCTION {format.tr.number}
 { type empty$
     { "Technical Report" }
@@ -1640,12 +1008,11 @@
     { number tie.or.space.connect }
   if$
 }
-
 % Now come the cross-referencing functions (these are invoked because
 % one entry in the database file(s) cross-references another, by giving
-% the other entry's database key in a `crossref' field).  This feature
+% the other entry's database key in a `crossref' field). This feature
 % allows one or more titled things that are part of a larger titled
-% thing to cross-reference the larger thing.  These styles allow for
+% thing to cross-reference the larger thing. These styles allow for
 % five posibilities: (1) an ARTICLE may cross-reference an ARTICLE;
 % (2) a BOOK, (3) INBOOK, or (4) INCOLLECTION may cross-reference a BOOK;
 % or (5) an INPROCEEDINGS may cross-reference a PROCEEDINGS.
@@ -1659,25 +1026,23 @@
 % if it's included in the reference list, but such is life.
 %
 % format.article.crossref ==
-%  BEGIN
-%       if empty$(key) then
-%           if empty$(journal) then
-%               warning$("need key or journal for " * cite$ *
-%                                               " to crossref " * crossref)
-%               return(" \cite{" * crossref * "}")
-%           else
-%               return("In " * emphazise.correct (journal) *
-%                                               " \cite{" * crossref * "}")
-%               fi
-%       else
-%           return("In " * key * " \cite{" * crossref * "}")
-%       fi
-%  END
+% BEGIN
+% if empty$(key) then
+% if empty$(journal) then
+% warning$("need key or journal for " * cite$ *
+% " to crossref " * crossref)
+% return(" \cite{" * crossref * "}")
+% else
+% return("In " * emphazise.correct (journal) *
+% " \cite{" * crossref * "}")
+% fi
+% else
+% return("In " * key * " \cite{" * crossref * "}")
+% fi
+% END
 %
 % The other cross-referencing functions are similar, so no "comment version"
 % will be given for them.
-
-#if !NAMED_REFS
 FUNCTION {format.article.crossref}
 { key empty$
     { journal empty$
@@ -1685,69 +1050,36 @@
           warning$
           ""
         }
-#if !JOUR_DEEMPH
         { "In {\em " journal * "\/}" * }
-#else JOUR_DEEMPH
-        { "In " journal * }
-#endif
       if$
     }
     { "In " key * }
   if$
   " \cite{" * crossref * "}" *
 }
-#else NAMED_REFS
-FUNCTION {format.article.crossref}
-{ "In"                                                  % this is for apalike
-  " \cite{" * crossref * "}" *
-}
-#endif NAMED_REFS
-
-#if !NAMED_REFS
 % We use just the last names of editors for a cross reference: either
 % "editor", or "editor1 and editor2", or "editor1 et~al." depending on
 % whether there are one, or two, or more than two editors.
-
 FUNCTION {format.crossref.editor}
-#if !CSC_NAMES
 { editor #1 "{vv~}{ll}" format.name$
-#else CSC_NAMES
-{ editor #1 "{vv~}{ll}" format.name$ caps
-#endif
   editor num.names$ duplicate$
-  #2 >
-#if !ETAL_EMPH
     { pop$ " et~al." * }
-#else ETAL_EMPH
-    { pop$ " {\em et~al.}" * }
-#endif ETAL_EMPH
     { #2 <
         'skip$
         { editor #2 "{ff }{vv }{ll}{ jj}" format.name$ "others" =
-#if !ETAL_EMPH
             { " et~al." * }
-#else ETAL_EMPH
-            { " {\em et~al.}" * }
-#endif ETAL_EMPH
-#if !CSC_NAMES
             { " and " * editor #2 "{vv~}{ll}" format.name$ * }
-#else CSC_NAMES
-            { " and " * editor #2 "{vv~}{ll}" format.name$ caps * }
-#endif
           if$
         }
       if$
     }
   if$
 }
-#endif
-
 % A BOOK (or INBOOK) entry type (assumed to be for a single volume in a
 % multivolume work) may cross reference another BOOK (the entire multivolume).
 % Usually there will be an editor, in which case we use that to construct the
 % cross reference; otherwise we use a nonempty key field or else the series
 % field (since the series gives the title of the multivolume work).
-
 FUNCTION {format.book.crossref}
 { volume empty$
     { "empty volume in " cite$ * "'s crossref of " * crossref * warning$
@@ -1757,7 +1089,6 @@
       " of " *
     }
   if$
-#if !NAMED_REFS
   editor empty$
   editor field.or.null author field.or.null =
   or
@@ -1776,18 +1107,12 @@
     { format.crossref.editor * }
   if$
   " \cite{" * crossref * "}" *
-#else NAMED_REFS
-  "\cite{" * crossref * "}" *                           % this is for apalike
-#endif
 }
-
 % An INCOLLECTION entry type may cross reference a BOOK (assumed to be the
 % collection), or an INPROCEEDINGS may cross reference a PROCEEDINGS.
 % Often there will be an editor, in which case we use that to construct
 % the cross reference; otherwise we use a nonempty key field or else
 % the booktitle field (which gives the cross-referenced work's title).
-
-#if !NAMED_REFS
 FUNCTION {format.incoll.inproc.crossref}
 { editor empty$
   editor field.or.null author field.or.null =
@@ -1808,131 +1133,84 @@
   if$
   " \cite{" * crossref * "}" *
 }
-#else NAMED_REFS
-FUNCTION {format.incoll.inproc.crossref}
-{ "In"                                                  % this is for apalike
-  " \cite{" * crossref * "}" *
-}
-#endif NAMED_REFS
-
 % Now we define the type functions for all entry types that may appear
-% in the .BIB file---e.g., functions like `article' and `book'.  These
+% in the .BIB file---e.g., functions like `article' and `book'. These
 % are the routines that actually generate the .BBL-file output for
-% the entry.  These must all precede the READ command.  In addition, the
+% the entry. These must all precede the READ command. In addition, the
 % style designer should have a function `default.type' for unknown types.
 % Note: The fields (within each list) are listed in order of appearance,
 % except as described for an `inbook' or a `proceedings'.
 %
-% The article function is for an article in a journal.  An article may
+% The article function is for an article in a journal. An article may
 % CROSSREF another article.
-%       Required fields: author, title, journal, year
-%       Optional fields: volume, number, pages, month, note
+% Required fields: author, title, journal, year
+% Optional fields: volume, number, pages, month, note
 %
 % article ==
-%  BEGIN
-%       output.bibitem
-%       output.check(format.authors,"author")
-%       new.block
-%       output.check(format.title,"title")
-%       new.block
-%       if missing$(crossref) then
-%           output.check(emphasize(journal),"journal")
-%           output(format.vol.num.pages)
-%           output.check(format.date,"year")
-%       else
-%           output.nonnull(format.article.crossref)
-%           output(format.pages)
-%       fi
-%       new.block
-%       output(note)
-%       fin.entry
-%  END
-%
-% The book function is for a whole book.  A book may CROSSREF another book.
-%       Required fields: author or editor, title, publisher, year
-%       Optional fields: volume or number, series, address, edition, month,
-%                       note
+% BEGIN
+% output.bibitem
+% output.check(format.authors,"author")
+% new.block
+% output.check(format.title,"title")
+% new.block
+% if missing$(crossref) then
+% output.check(emphasize(journal),"journal")
+% output(format.vol.num.pages)
+% output.check(format.date,"year")
+% else
+% output.nonnull(format.article.crossref)
+% output(format.pages)
+% fi
+% new.block
+% output(note)
+% fin.entry
+% END
+%
+% The book function is for a whole book. A book may CROSSREF another book.
+% Required fields: author or editor, title, publisher, year
+% Optional fields: volume or number, series, address, edition, month,
+% note
 %
 % book ==
-%  BEGIN
-%       if empty$(author) then output.check(format.editors,"author and editor")
-%       else    output.check(format.authors,"author")
-%               if missing$(crossref) then
-%                   either.or.check("author and editor",editor)
-%               fi
-%       fi
-%       new.block
-%       output.check(format.btitle,"title")
-%       if missing$(crossref) then
-%           output(format.bvolume)
-%           new.block
-%           output(format.number.series)
-%           new.sentence
-%           output.check(publisher,"publisher")
-%           output(address)
-%       else
-%           new.block
-%           output.nonnull(format.book.crossref)
-%       fi
-%       output(format.edition)
-%       output.check(format.date,"year")
-%       new.block
-%       output(note)
-%       fin.entry
-%  END
+% BEGIN
+% if empty$(author) then output.check(format.editors,"author and editor")
+% else output.check(format.authors,"author")
+% if missing$(crossref) then
+% either.or.check("author and editor",editor)
+% fi
+% fi
+% new.block
+% output.check(format.btitle,"title")
+% if missing$(crossref) then
+% output(format.bvolume)
+% new.block
+% output(format.number.series)
+% new.sentence
+% output.check(publisher,"publisher")
+% output(address)
+% else
+% new.block
+% output.nonnull(format.book.crossref)
+% fi
+% output(format.edition)
+% output.check(format.date,"year")
+% new.block
+% output(note)
+% fin.entry
+% END
 %
 % The other entry functions are all quite similar, so no "comment version"
 % will be given for them.
-
 FUNCTION {article}
 { output.bibitem
   format.authors "author" output.check
-#if NAMED_REFS
-  author format.key output                              % special for
-  output.year.check                                     % apalike
-#endif NAMED_REFS
-#if !ATIT_SUPPRESS
   new.block
   format.title "title" output.check
-#endif
   new.block
   crossref missing$
-#if !VOLUME_SPACE
-#if !JOUR_DEEMPH
     { journal emphasize "journal" output.check
-#else JOUR_DEEMPH
-    { journal "journal" output.check
-#endif
-#else VOLUME_SPACE
-#if !JOUR_DEEMPH
-    { journal emphasize
-#else JOUR_DEEMPH
-    { journal field.or.null
-#endif
-#endif
-#if !NAMED_REFS
-#if !DATE_FIRST
-#if !PAREN_DATE
       format.vol.num.pages output
       format.date "year" output.check
-#else PAREN_DATE
-      format.vol.num.pages 
-      format.date empty$
-        'skip$
-        { duplicate$ empty$
-            { pop$ format.date paren }
-            { " " * format.date paren * }
-          if$
-        }
-      if$
-      output
-#endif
-#else DATE_FIRST
-      format.vol.num.pages output
-#endif DATE_FIRST
-#else NAMED_REFS
-      format.vol.num.pages output
-#endif NAMED_REFS
     }
     { format.article.crossref output.nonnull
       format.pages output
@@ -1942,17 +1220,10 @@
   note output
   fin.entry
 }
-
 FUNCTION {book}
 { output.bibitem
   author empty$
-#if !NAMED_REFS
     { format.editors "author and editor" output.check }
-#else NAMED_REFS
-    { format.editors "author and editor" output.check
-      editor format.key output
-    }
-#endif NAMED_REFS
     { format.authors output.nonnull
       crossref missing$
         { "author and editor" editor either.or.check }
@@ -1960,9 +1231,6 @@
       if$
     }
   if$
-#if NAMED_REFS
-  output.year.check                             % special for apalike
-#endif
   new.block
   format.btitle "title" output.check
   crossref missing$
@@ -1978,60 +1246,37 @@
     }
   if$
   format.edition output
-#if !NAMED_REFS
   format.date "year" output.check
-#endif
   new.block
   note output
   fin.entry
 }
-
 % A booklet is a bound thing without a publisher or sponsoring institution.
-%       Required: title
-%       Optional: author, howpublished, address, month, year, note
-
+% Required: title
+% Optional: author, howpublished, address, month, year, note
 FUNCTION {booklet}
 { output.bibitem
   format.authors output
-#if !NAMED_REFS
   new.block
   format.title "title" output.check
   howpublished address new.block.checkb
   howpublished output
   address output
   format.date output
-#else NAMED_REFS
-  author format.key output                              % special for
-  output.year.check                                     % apalike
-  new.block
-  format.title "title" output.check
-  new.block
-  howpublished output
-  address output
-#endif NAMED_REFS
   new.block
   note output
   fin.entry
 }
-
 % For the conference entry type, see inproceedings.
-
 % An inbook is a piece of a book: either a chapter and/or a page range.
-% It may CROSSREF a book.  If there's no volume field, the type field
+% It may CROSSREF a book. If there's no volume field, the type field
 % will come before number and series.
-%       Required: author or editor, title, chapter and/or pages, publisher,year
-%       Optional: volume or number, series, type, address, edition, month, note
-
+% Required: author or editor, title, chapter and/or pages, publisher,year
+% Optional: volume or number, series, type, address, edition, month, note
 FUNCTION {inbook}
 { output.bibitem
   author empty$
-#if !NAMED_REFS
     { format.editors "author and editor" output.check }
-#else NAMED_REFS
-    { format.editors "author and editor" output.check
-      editor format.key output
-    }
-#endif
     { format.authors output.nonnull
       crossref missing$
         { "author and editor" editor either.or.check }
@@ -2039,9 +1284,6 @@
       if$
     }
   if$
-#if NAMED_REFS
-  output.year.check                             % special for apalike
-#endif
   new.block
   format.btitle "title" output.check
   crossref missing$
@@ -2059,28 +1301,20 @@
     }
   if$
   format.edition output
-#if !NAMED_REFS
   format.date "year" output.check
-#endif
   new.block
   note output
   fin.entry
 }
-
 % An incollection is like inbook, but where there is a separate title
 % for the referenced thing (and perhaps an editor for the whole).
 % An incollection may CROSSREF a book.
-%       Required: author, title, booktitle, publisher, year
-%       Optional: editor, volume or number, series, type, chapter, pages,
-%                       address, edition, month, note
-
+% Required: author, title, booktitle, publisher, year
+% Optional: editor, volume or number, series, type, chapter, pages,
+% address, edition, month, note
 FUNCTION {incollection}
 { output.bibitem
   format.authors "author" output.check
-#if NAMED_REFS
-  author format.key output                              % special for
-  output.year.check                                     % apalike
-#endif NAMED_REFS
   new.block
   format.title "title" output.check
   new.block
@@ -2093,9 +1327,7 @@
       publisher "publisher" output.check
       address output
       format.edition output
-#if !NAMED_REFS
       format.date "year" output.check
-#endif !NAMED_REFS
     }
     { format.incoll.inproc.crossref output.nonnull
       format.chapter.pages output
@@ -2105,21 +1337,15 @@
   note output
   fin.entry
 }
-
 % An inproceedings is an article in a conference proceedings, and it may
-% CROSSREF a proceedings.  If there's no address field, the month (& year)
+% CROSSREF a proceedings. If there's no address field, the month (& year)
 % will appear just before note.
-%       Required: author, title, booktitle, year
-%       Optional: editor, volume or number, series, pages, address, month,
-%                       organization, publisher, note
-
+% Required: author, title, booktitle, year
+% Optional: editor, volume or number, series, pages, address, month,
+% organization, publisher, note
 FUNCTION {inproceedings}
 { output.bibitem
   format.authors "author" output.check
-#if NAMED_REFS
-  author format.key output                              % special for
-  output.year.check                                     % apalike
-#endif NAMED_REFS
   new.block
   format.title "title" output.check
   new.block
@@ -2128,7 +1354,6 @@
       format.bvolume output
       format.number.series output
       format.pages output
-#if !NAMED_REFS
       address empty$
         { organization publisher new.sentence.checkb
           organization output
@@ -2142,12 +1367,6 @@
           publisher output
         }
       if$
-#else NAMED_REFS
-      address output                                    % for apalike
-      new.sentence                                      % there's no year
-      organization output                               % here so things
-      publisher output                                  % are simpler
-#endif NAMED_REFS
     }
     { format.incoll.inproc.crossref output.nonnull
       format.pages output
@@ -2157,18 +1376,13 @@
   note output
   fin.entry
 }
-
 % The conference function is included for Scribe compatibility.
-
 FUNCTION {conference} { inproceedings }
-
 % A manual is technical documentation.
-%       Required: title
-%       Optional: author, organization, address, edition, month, year, note
-
+% Required: title
+% Optional: author, organization, address, edition, month, year, note
 FUNCTION {manual}
 { output.bibitem
-#if !NAMED_REFS
   author empty$
     { organization empty$
         'skip$
@@ -2196,126 +1410,77 @@
   if$
   format.edition output
   format.date output
-#else NAMED_REFS
-  format.authors output
-  author format.key output                              % special for
-  output.year.check                                     % apalike
-  new.block
-  format.btitle "title" output.check
-  organization address new.block.checkb
-  organization output
-  address output
-  format.edition output
-#endif NAMED_REFS
   new.block
   note output
   fin.entry
 }
-
 % A mastersthesis is a Master's thesis.
-%       Required: author, title, school, year
-%       Optional: type, address, month, note
-
+% Required: author, title, school, year
+% Optional: type, address, month, note
 FUNCTION {mastersthesis}
 { output.bibitem
   format.authors "author" output.check
-#if NAMED_REFS
-  author format.key output                              % special for
-  output.year.check                                     % apalike
-#endif NAMED_REFS
   new.block
   format.title "title" output.check
   new.block
   "Master's thesis" format.thesis.type output.nonnull
   school "school" output.check
   address output
-#if !NAMED_REFS
   format.date "year" output.check
-#endif !NAMED_REFS
   new.block
   note output
   fin.entry
 }
-
 % A misc is something that doesn't fit elsewhere.
-%       Required: at least one of the `optional' fields
-%       Optional: author, title, howpublished, month, year, note
-
+% Required: at least one of the `optional' fields
+% Optional: author, title, howpublished, month, year, note
 FUNCTION {misc}
 { output.bibitem
   format.authors output
-#if !NAMED_REFS
   title howpublished new.block.checkb
   format.title output
   howpublished new.block.checka
   howpublished output
   format.date output
-#else NAMED_REFS
-  author format.key output                              % special for
-  output.year.check                                     % apalike
-  new.block
-  format.title output
-  new.block
-  howpublished output
-#endif NAMED_REFS
   new.block
   note output
   fin.entry
-#if !NAMED_REFS
   empty.misc.check
-#endif
 }
-
 % A phdthesis is like a mastersthesis.
-%       Required: author, title, school, year
-%       Optional: type, address, month, note
-
+% Required: author, title, school, year
+% Optional: type, address, month, note
 FUNCTION {phdthesis}
 { output.bibitem
   format.authors "author" output.check
-#if NAMED_REFS
-  author format.key output                              % special for
-  output.year.check                                     % apalike
-#endif NAMED_REFS
   new.block
   format.btitle "title" output.check
   new.block
   "PhD thesis" format.thesis.type output.nonnull
   school "school" output.check
   address output
-#if !NAMED_REFS
   format.date "year" output.check
-#endif !NAMED_REFS
   new.block
   note output
   fin.entry
 }
-
 % A proceedings is a conference proceedings.
 % If there is an organization but no editor field, the organization will
 % appear as the first optional field (we try to make the first block nonempty);
 % if there's no address field, the month (& year) will appear just before note.
-%       Required: title, year
-%       Optional: editor, volume or number, series, address, month,
-%                       organization, publisher, note
-
+% Required: title, year
+% Optional: editor, volume or number, series, address, month,
+% organization, publisher, note
 FUNCTION {proceedings}
 { output.bibitem
-#if !NAMED_REFS
   editor empty$
     { organization output }
     { format.editors output.nonnull }
   if$
-#else NAMED_REFS
-  format.editors output
-  editor format.key output                              % special for
-  output.year.check                                     % apalike
-#endif NAMED_REFS
   new.block
   format.btitle "title" output.check
   format.bvolume output
   format.number.series output
-#if !NAMED_REFS
   address empty$
     { editor empty$
         { publisher new.sentence.checka }
@@ -2336,273 +1501,93 @@
       publisher output
     }
   if$
-#else NAMED_REFS
-  address output                                % for apalike
-  new.sentence                                  % we always output
-  organization output                           % a nonempty organization
-  publisher output                              % here
-#endif NAMED_REFS
   new.block
   note output
   fin.entry
 }
-
 % A techreport is a technical report.
-%       Required: author, title, institution, year
-%       Optional: type, number, address, month, note
-
+% Required: author, title, institution, year
+% Optional: type, number, address, month, note
 FUNCTION {techreport}
 { output.bibitem
   format.authors "author" output.check
-#if NAMED_REFS
-  author format.key output                              % special for
-  output.year.check                                     % apalike
-#endif NAMED_REFS
   new.block
   format.title "title" output.check
   new.block
   format.tr.number output.nonnull
   institution "institution" output.check
   address output
-#if !NAMED_REFS
   format.date "year" output.check
-#endif !NAMED_REFS
   new.block
   note output
   fin.entry
 }
-
 % An unpublished is something that hasn't been published.
-%       Required: author, title, note
-%       Optional: month, year
-
+% Required: author, title, note
+% Optional: month, year
 FUNCTION {unpublished}
 { output.bibitem
   format.authors "author" output.check
-#if NAMED_REFS
-  author format.key output                              % special for
-  output.year.check                                     % apalike
-#endif NAMED_REFS
   new.block
   format.title "title" output.check
   new.block
   note "note" output.check
-#if !NAMED_REFS
   format.date output
-#endif
   fin.entry
 }
-
 % We use entry type `misc' for an unknown type; BibTeX gives a warning.
-
 FUNCTION {default.type} { misc }
-
 % Here are macros for common things that may vary from style to style.
 % Users are encouraged to use these macros.
 %
 % Months are either written out in full or abbreviated
-
-#if MONTH_FULL
-
-MACRO {jan} {"January"}
-
-MACRO {feb} {"February"}
-
-MACRO {mar} {"March"}
-
-MACRO {apr} {"April"}
-
-MACRO {may} {"May"}
-
-MACRO {jun} {"June"}
-
-MACRO {jul} {"July"}
-
-MACRO {aug} {"August"}
-
-MACRO {sep} {"September"}
-
-MACRO {oct} {"October"}
-
-MACRO {nov} {"November"}
-
-MACRO {dec} {"December"}
-
-#else !MONTH_FULL
-
 MACRO {jan} {"Jan."}
-
 MACRO {feb} {"Feb."}
-
 MACRO {mar} {"Mar."}
-
 MACRO {apr} {"Apr."}
-
 MACRO {may} {"May"}
-
 MACRO {jun} {"June"}
-
 MACRO {jul} {"July"}
-
 MACRO {aug} {"Aug."}
-
 MACRO {sep} {"Sept."}
-
 MACRO {oct} {"Oct."}
-
 MACRO {nov} {"Nov."}
-
 MACRO {dec} {"Dec."}
-
-#endif MONTH_FULL
-
 % Journals are either written out in full or abbreviated;
 % the abbreviations are like those found in ACM publications.
 %
 % To get a completely different set of abbreviations, it may be best to make
 % a separate .bib file with nothing but those abbreviations; users could then
 % include that file name as the first argument to the \bibliography command
-
-#if JOUR_FULL
-
-MACRO {acmcs} {"ACM Computing Surveys"}
-
-MACRO {acta} {"Acta Informatica"}
-
-MACRO {cacm} {"Communications of the ACM"}
-
-MACRO {ibmjrd} {"IBM Journal of Research and Development"}
-
-MACRO {ibmsj} {"IBM Systems Journal"}
-
-MACRO {ieeese} {"IEEE Transactions on Software Engineering"}
-
-MACRO {ieeetc} {"IEEE Transactions on Computers"}
-
-MACRO {ieeetcad}
- {"IEEE Transactions on Computer-Aided Design of Integrated Circuits"}
-
-MACRO {ipl} {"Information Processing Letters"}
-
-MACRO {jacm} {"Journal of the ACM"}
-
-MACRO {jcss} {"Journal of Computer and System Sciences"}
-
-MACRO {scp} {"Science of Computer Programming"}
-
-MACRO {sicomp} {"SIAM Journal on Computing"}
-
-MACRO {tocs} {"ACM Transactions on Computer Systems"}
-
-MACRO {tods} {"ACM Transactions on Database Systems"}
-
-MACRO {tog} {"ACM Transactions on Graphics"}
-
-MACRO {toms} {"ACM Transactions on Mathematical Software"}
-
-MACRO {toois} {"ACM Transactions on Office Information Systems"}
-
-MACRO {toplas} {"ACM Transactions on Programming Languages and Systems"}
-
-MACRO {tcs} {"Theoretical Computer Science"}
-
-#else !JOUR_FULL
-
 MACRO {acmcs} {"ACM Comput. Surv."}
-
 MACRO {acta} {"Acta Inf."}
-
 MACRO {cacm} {"Commun. ACM"}
-
 MACRO {ibmjrd} {"IBM J. Res. Dev."}
-
 MACRO {ibmsj} {"IBM Syst.~J."}
-
 MACRO {ieeese} {"IEEE Trans. Softw. Eng."}
-
 MACRO {ieeetc} {"IEEE Trans. Comput."}
-
 MACRO {ieeetcad}
  {"IEEE Trans. Comput.-Aided Design Integrated Circuits"}
-
 MACRO {ipl} {"Inf. Process. Lett."}
-
 MACRO {jacm} {"J.~ACM"}
-
 MACRO {jcss} {"J.~Comput. Syst. Sci."}
-
 MACRO {scp} {"Sci. Comput. Programming"}
-
 MACRO {sicomp} {"SIAM J. Comput."}
-
 MACRO {tocs} {"ACM Trans. Comput. Syst."}
-
 MACRO {tods} {"ACM Trans. Database Syst."}
-
 MACRO {tog} {"ACM Trans. Gr."}
-
 MACRO {toms} {"ACM Trans. Math. Softw."}
-
 MACRO {toois} {"ACM Trans. Office Inf. Syst."}
-
 MACRO {toplas} {"ACM Trans. Prog. Lang. Syst."}
-
 MACRO {tcs} {"Theoretical Comput. Sci."}
-
-#if PHYSICS_JOUR
-#include "journal-abbrev.bst"
-#endif PHYSICS_JOUR
-
-#endif JOUR_FULL
-
 % Now we read in the .BIB entries.
-
 READ
-
 % The sortify function converts to lower case after purify$ing; it's
 % used in sorting and in computing alphabetic labels after sorting
 %
 % The chop.word(w,len,s) function returns either s or, if the first len
 % letters of s equals w (this comparison is done in the third line of the
 % function's definition), it returns that part of s after w.
-
-#if SORTED
-
-FUNCTION {sortify}
-{ purify$
-  "l" change.case$
-}
-
-INTEGERS { len }
-
-FUNCTION {chop.word}
-{ 's :=
-  'len :=
-  s #1 len substring$ =
-    { s len #1 + global.max$ substring$ }
-    's
-  if$
-}
-
-#else !SORTED
-#if LAB_ALPH
-
-% We need the chop.word stuff for the dubious unsorted-list-with-labels case.
-
-INTEGERS { len }
-
-FUNCTION {chop.word}
-{ 's :=
-  'len :=
-  s #1 len substring$ =
-    { s len #1 + global.max$ substring$ }
-    's
-  if$
-}
-
-#endif LAB_ALPH
-#endif SORTED
-
 % This long comment applies only to alphabetic labels
 %
 % The format.lab.names function makes a short label by using the initials of
@@ -2611,55 +1596,55 @@
 % it also adds such a "+" if the last of multiple authors is "others").
 % If there is only one name, and its von and Last parts combined have just
 % a single name-token ("Knuth" has a single token, "Brinch Hansen" has two),
-% we take the first three letters of the last name.  The boolean
+% we take the first three letters of the last name. The boolean
 % et.al.char.used tells whether we've used a superscripted "+", so that we
 % know whether to include a LaTeX macro for it.
 %
 % format.lab.names(s) ==
-%  BEGIN
-%       numnames := num.names$(s)
-%       if numnames > 1 then
-%           if numnames > 4 then
-%               namesleft := 3
-%           else
-%               namesleft := numnames
-%           nameptr := 1
-%           nameresult := ""
-%           while namesleft > 0
-%             do
-%               if (name_ptr = numnames) and
-%                    format.name$(s, nameptr, "{ff }{vv }{ll}{ jj}") = "others"
-%                  then nameresult := nameresult * "{\etalchar{+}}"
-%                       et.al.char.used := true
-%                  else nameresult := nameresult *
-%                               format.name$(s, nameptr, "{v{}}{l{}}")
-%               nameptr := nameptr + 1
-%               namesleft := namesleft - 1
-%             od
-%           if numnames > 4 then
-%               nameresult := nameresult * "{\etalchar{+}}"
-%               et.al.char.used := true
-%       else
-%           t := format.name$(s, 1, "{v{}}{l{}}")
-%           if text.length$(t) < 2 then % there's just one name-token
-%               nameresult := text.prefix$(format.name$(s,1,"{ll}"),3)
-%           else
-%               nameresult := t
-%           fi
-%       fi
-%       return nameresult
-%  END
+% BEGIN
+% numnames := num.names$(s)
+% if numnames > 1 then
+% if numnames > 4 then
+% namesleft := 3
+% else
+% namesleft := numnames
+% nameptr := 1
+% nameresult := ""
+% while namesleft > 0
+% do
+% if (name_ptr = numnames) and
+% format.name$(s, nameptr, "{ff }{vv }{ll}{ jj}") = "others"
+% then nameresult := nameresult * "{\etalchar{+}}"
+% et.al.char.used := true
+% else nameresult := nameresult *
+% format.name$(s, nameptr, "{v{}}{l{}}")
+% nameptr := nameptr + 1
+% namesleft := namesleft - 1
+% od
+% if numnames > 4 then
+% nameresult := nameresult * "{\etalchar{+}}"
+% et.al.char.used := true
+% else
+% t := format.name$(s, 1, "{v{}}{l{}}")
+% if text.length$(t) < 2 then % there's just one name-token
+% nameresult := text.prefix$(format.name$(s,1,"{ll}"),3)
+% else
+% nameresult := t
+% fi
+% fi
+% return nameresult
+% END
 %
 % Exactly what fields we look at in constructing the primary part of the label
 % depends on the entry type; this selectivity (as opposed to, say, always
 % looking at author, then editor, then key) helps ensure that "ignored" fields,
-% as described in the LaTeX book, really are ignored.  Note that MISC is part
+% as described in the LaTeX book, really are ignored. Note that MISC is part
 % of the deepest `else' clause in the nested part of calc.label; thus, any
 % unrecognized entry type in the database is handled correctly.
 %
 % There is one auxiliary function for each of the four different sequences of
-% fields we use.  The first of these functions looks at the author field, and
-% then, if necessary, the key field.  The other three functions, which might
+% fields we use. The first of these functions looks at the author field, and
+% then, if necessary, the key field. The other three functions, which might
 % look at two fields and the key field, are similar, except that the key field
 % takes precedence over the organization field (for labels---not for sorting).
 %
@@ -2680,331 +1665,23 @@
 % until after sorting.
 %
 % calc.label ==
-%  BEGIN
-%       if type$ = "book" or "inbook" then
-%           author.editor.key.label
-%       else if type$ = "proceedings" then
-%           editor.key.organization.label
-%       else if type$ = "manual" then
-%           author.key.organization.label
-%       else
-%           author.key.label
-%       fi fi fi
-%       label := label * substring$(purify$(field.or.null(year)), -1, 2)
-%               % assuming we will also sort, we calculate a sort.label
-%       sort.label := sortify(label), but use the last four, not two, digits
-%  END
-
-#if LAB_ALPH
-
-#if !NAMED_REFS
-INTEGERS { et.al.char.used }
-
-FUNCTION {initialize.et.al.char.used}
-{ #0 'et.al.char.used :=
-}
-
-EXECUTE {initialize.et.al.char.used}
-#endif !NAMED_REFS
-
-#if !NAMED_REFS
-FUNCTION {format.lab.names}
-#if !RMP_LABELS
-{ 's :=
-  s num.names$ 'numnames :=
-  numnames #1 >
-    { numnames #4 >
-        { #3 'namesleft := }
-        { numnames 'namesleft := }
-      if$
-      #1 'nameptr :=
-      ""
-        { namesleft #0 > }
-        { nameptr numnames =
-            { s nameptr "{ff }{vv }{ll}{ jj}" format.name$ "others" =
-                { "{\etalchar{+}}" *
-                  #1 'et.al.char.used :=
-                }
-                { s nameptr "{v{}}{l{}}" format.name$ * }
-              if$
-            }
-            { s nameptr "{v{}}{l{}}" format.name$ * }
-          if$
-          nameptr #1 + 'nameptr :=
-          namesleft #1 - 'namesleft :=
-        }
-      while$
-      numnames #4 >
-        { "{\etalchar{+}}" *
-          #1 'et.al.char.used :=
-        }
-        'skip$
-      if$
-    }
-    { s #1 "{v{}}{l{}}" format.name$
-      duplicate$ text.length$ #2 <
-        { pop$ s #1 "{ll}" format.name$ #3 text.prefix$ }
-        'skip$
-      if$
-    }
-  if$
-}
-#else RMP_LABELS
-{ 's :=
-  s num.names$ 'numnames :=
-  numnames #1 >
-    { numnames #2 >
-#if !CSC_NAMES
-#if !ETAL_EMPH
-       { s #1 "{vv }{ll}" format.name$ " et~al." * }
-#else ETAL_EMPH
-       { s #1 "{vv }{ll}" format.name$ " {\em et~al.}" * }
-#endif ETAL_EMPH
-       { s #1 "{vv }{ll}" format.name$
-#else CSC_NAMES
-#if !ETAL_EMPH
-       { s #1 "{vv }{ll}" format.name$ caps " et~al." * }
-#else ETAL_EMPH
-       { s #1 "{vv }{ll}" format.name$ caps " {\em et~al.}" * }
-#endif ETAL_EMPH
-       { s #1 "{vv }{ll}" format.name$ caps
-#endif CSC_NAMES
-         s #2 "{ff }{vv }{ll}{ jj}" format.name$ "others" =
-#if !ETAL_EMPH
-            { " et~al." * }
-#else ETAL_EMPH
-            { " {\em et~al.}" * }
-#endif ETAL_EMPH
-#if !CSC_NAMES
-            { " and " * s #2 "{vv }{ll}" format.name$ * }
-#else CSC_NAMES
-            { " and " * s #2 "{vv }{ll}" format.name$ caps * }
-#endif CSC_NAMES
-         if$
-       }
-      if$
-    }
-#if !CSC_NAMES
-    { s #1 "{vv }{ll}" format.name$ }
-#else CSC_NAMES
-    { s #1 "{vv }{ll}" format.name$ caps }
-#endif
-  if$
-}
-#endif
-#else NAMED_REFS
-%                       There are three apalike cases: one person (Jones),
-%                       two (Jones and de~Bruijn), and more (Jones et~al.).
-%                       This function is much like format.crossref.editors.
-%
-FUNCTION {format.lab.names}
-{ 's :=
-#if !CSC_NAMES
-  s #1 "{vv~}{ll}" format.name$
-#else CSC_NAMES
-  s #1 "{vv~}{ll}" format.name$ caps
-#endif CSC_NAMES
-  s num.names$ duplicate$
-  #2 >
-#if !ETAL_EMPH
-    { pop$ " et~al." * }
-#else ETAL_EMPH
-    { pop$ " {\em et~al.}" * }
-#endif ETAL_EMPH
-    { #2 <
-        'skip$
-        { s #2 "{ff }{vv }{ll}{ jj}" format.name$ "others" =
-#if !ETAL_EMPH
-            { " et~al." * }
-#else ETAL_EMPH
-            { " {\em et~al.}" * }
-#endif ETAL_EMPH
-#if !CSC_NAMES
-            { " and " * s #2 "{vv~}{ll}" format.name$ * }
-#else CSC_NAMES
-            { " and " * s #2 "{vv~}{ll}" format.name$ caps * }
-#endif
-          if$
-        }
-      if$
-    }
-  if$
-}
-#endif NAMED_REFS
-
-FUNCTION {author.key.label}
-{ author empty$
-    { key empty$
-#if SORTED
-        { cite$ #1 #3 substring$ }
-#else !SORTED           % need warning here because we won't give it later
-        { "for label, need author or key in " cite$ * warning$
-          cite$ #1 #3 substring$
-        }
-#endif SORTED
-#if !NAMED_REFS
-        { key #3 text.prefix$ }
-#else NAMED_REFS
-        'key                                    % apalike uses the whole key
-#endif NAMED_REFS
-      if$
-    }
-    { author format.lab.names }
-  if$
-}
-
-FUNCTION {author.editor.key.label}
-{ author empty$
-    { editor empty$
-        { key empty$
-#if SORTED
-            { cite$ #1 #3 substring$ }
-#else !SORTED           % need warning here because we won't give it later
-            { "for label, need author, editor, or key in " cite$ * warning$
-              cite$ #1 #3 substring$
-            }
-#endif SORTED
-#if !NAMED_REFS
-            { key #3 text.prefix$ }
-#else NAMED_REFS
-            'key                                % apalike uses the whole key
-#endif NAMED_REFS
-          if$
-        }
-        { editor format.lab.names }
-      if$
-    }
-    { author format.lab.names }
-  if$
-}
-
-#if !NAMED_REFS
-FUNCTION {author.key.organization.label}
-{ author empty$
-    { key empty$
-        { organization empty$
-#if SORTED
-            { cite$ #1 #3 substring$ }
-#else !SORTED           % need warning here because we won't give it later
-            { "for label, need author, key, or organization in " cite$ *
-                                                                warning$
-              cite$ #1 #3 substring$
-            }
-#endif SORTED
-#if !RMP_LABELS
-            { "The " #4 organization chop.word #3 text.prefix$ }
-#else RMP_LABELS
-            { "The " #4 organization chop.word #9 text.prefix$ }
-#endif
-          if$
-        }
-        { key #3 text.prefix$ }
-      if$
-    }
-    { author format.lab.names }
-  if$
-}
-
-FUNCTION {editor.key.organization.label}
-{ editor empty$
-    { key empty$
-        { organization empty$
-#if SORTED
-            { cite$ #1 #3 substring$ }
-#else !SORTED           % need warning here because we won't give it later
-            { "for label, need editor, key, or organization in " cite$ *
-                                                                warning$
-              cite$ #1 #3 substring$
-            }
-#endif SORTED
-#if !RMP_LABELS
-            { "The " #4 organization chop.word #3 text.prefix$ }
-#else RMP_LABELS
-            { "The " #4 organization chop.word #9 text.prefix$ }
-#endif
-          if$
-        }
-        { key #3 text.prefix$ }
-      if$
-    }
-    { editor format.lab.names }
-  if$
-}
-#else NAMED_REFS
-FUNCTION {editor.key.label}
-{ editor empty$
-    { key empty$
-        { cite$ #1 #3 substring$ }
-        'key                    % apalike uses the whole key, no organization
-      if$
-    }
-    { editor format.lab.names }
-  if$
-}
-#endif NAMED_REFS
-
-FUNCTION {calc.label}
-#if !KEY_CITE
-{ type$ "book" =
-  type$ "inbook" =
-  or
-    'author.editor.key.label
-    { type$ "proceedings" =
-#if !NAMED_REFS
-        'editor.key.organization.label
-        { type$ "manual" =
-            'author.key.organization.label
-            'author.key.label
-          if$
-        }
-#else NAMED_REFS
-        'editor.key.label                       % apalike ignores organization
-        'author.key.label                       % for labeling and sorting
-#endif NAMED_REFS
-      if$
-    }
-  if$
-#if !NAMED_REFS
-  duplicate$
-#if !RMP_LABELS
-  year field.or.null purify$ #-1 #2 substring$
-#else RMP_LABELS
-  " " * year field.or.null purify$ #-1 #4 substring$
-#endif
-  *
-  'label :=
-  year field.or.null purify$ #-1 #4 substring$
-  *
-  sortify 'sort.label :=
-#else NAMED_REFS
-  ", "                                                  % these three lines are
-  *                                                     % for apalike, which
-  year field.or.null purify$ #-1 #4 substring$          % uses all four digits
-  *
-  'label :=
-#endif NAMED_REFS
-}
-#else KEY_CITE
-{ cite$ 'label :=
-label sortify 'sort.label :=
-}
-#endif
-
-% It doesn't seem like a particularly good idea to use an order-of-citation
-% reference list when using alphabetic labels, but we need to have a
-% special pass to calculate labels when this happens.
-
-#if !SORTED
-
-ITERATE {calc.label}
-
-#endif !SORTED
-
-#endif LAB_ALPH
-
+% BEGIN
+% if type$ = "book" or "inbook" then
+% author.editor.key.label
+% else if type$ = "proceedings" then
+% editor.key.organization.label
+% else if type$ = "manual" then
+% author.key.organization.label
+% else
+% author.key.label
+% fi fi fi
+% label := label * substring$(purify$(field.or.null(year)), -1, 2)
+% % assuming we will also sort, we calculate a sort.label
+% sort.label := sortify(label), but use the last four, not two, digits
+% END
 % When sorting, we compute the sortkey by executing "presort" on each entry.
 % The presort key contains a number of "sortify"ed strings, concatenated
-% with multiple blanks between them.  This makes things like "brinch  per"
+% with multiple blanks between them. This makes things like "brinch  per"
 % come before "brinch hansen  per".
 %
 % The fields used here are: the sort.label for alphabetic labels (as set by
@@ -3021,232 +1698,12 @@
 %
 % The sort.format.names function takes an argument that should be in
 % BibTeX name format, and returns a string containing "   "-separated
-% names in the format described above.  The function is almost the same
+% names in the format described above. The function is almost the same
 % as format.names.
-
-#if SORTED
-
-FUNCTION {sort.format.names}
-{ 's :=
-  #1 'nameptr :=
-  ""
-  s num.names$ 'numnames :=
-  numnames 'namesleft :=
-    { namesleft #0 > }
-    { nameptr #1 >
-        { "   " * }
-        'skip$
-#if NAME_FULL
-      if$
-      s nameptr "{vv{ } }{ll{ }}{  ff{ }}{  jj{ }}" format.name$ 't :=
-#else
-      if$                                               % apalike uses initials
-      s nameptr "{vv{ } }{ll{ }}{  f{ }}{  jj{ }}" format.name$ 't := % <= here
-#endif NAME_FULL
-      nameptr numnames = t "others" = and
-        { "et al" * }
-        { t sortify * }
-      if$
-      nameptr #1 + 'nameptr :=
-      namesleft #1 - 'namesleft :=
-    }
-  while$
-}
-
-% The sort.format.title function returns the argument,
-% but first any leading "A "'s, "An "'s, or "The "'s are removed.
-% The chop.word function uses s, so we need another string variable, t
-
-FUNCTION {sort.format.title}
-{ 't :=
-  "A " #2
-    "An " #3
-      "The " #4 t chop.word
-    chop.word
-  chop.word
-  sortify
-  #1 global.max$ substring$
-}
-
-% The auxiliary functions here, for the presort function, are analogous to
-% the ones for calc.label; the same comments apply, except that the
-% organization field takes precedence here over the key field.  For sorting
-% purposes, we still remove a leading "The " from the organization field.
-
-FUNCTION {author.sort}
-{ author empty$
-    { key empty$
-        { "to sort, need author or key in " cite$ * warning$
-          ""
-        }
-        { key sortify }
-      if$
-    }
-    { author sort.format.names }
-  if$
-}
-
-FUNCTION {author.editor.sort}
-{ author empty$
-    { editor empty$
-        { key empty$
-            { "to sort, need author, editor, or key in " cite$ * warning$
-              ""
-            }
-            { key sortify }
-          if$
-        }
-        { editor sort.format.names }
-      if$
-    }
-    { author sort.format.names }
-  if$
-}
-
-#if !NAMED_REFS
-FUNCTION {author.organization.sort}
-{ author empty$
-    { organization empty$
-        { key empty$
-            { "to sort, need author, organization, or key in " cite$ * warning$
-              ""
-            }
-            { key sortify }
-          if$
-        }
-        { "The " #4 organization chop.word sortify }
-      if$
-    }
-    { author sort.format.names }
-  if$
-}
-
-FUNCTION {editor.organization.sort}
-{ editor empty$
-    { organization empty$
-        { key empty$
-            { "to sort, need editor, organization, or key in " cite$ * warning$
-              ""
-            }
-            { key sortify }
-          if$
-        }
-        { "The " #4 organization chop.word sortify }
-      if$
-    }
-    { editor sort.format.names }
-  if$
-}
-#else NAMED_REFS
-FUNCTION {editor.sort}
-{ editor empty$
-    { key empty$
-        { "to sort, need editor or key in " cite$ * warning$
-          ""
-        }
-        { key sortify }
-      if$
-    }
-    { editor sort.format.names }
-  if$
-}
-#endif NAMED_REFS
-
-#if !NAMED_REFS
-% There is a limit, entry.max$, on the length of an entry string variable
-% (which is what its sort.key$ is), so we take at most that many characters
-% of the constructed key, and hope there aren't many references that match
-% to that many characters!
-
-FUNCTION {presort}
-#if LAB_ALPH
-{ calc.label
-  sort.label
-  "    "
-  *
-  type$ "book" =
-#else !LAB_ALPH
-{ type$ "book" =
-#endif LAB_ALPH
-  type$ "inbook" =
-  or
-    'author.editor.sort
-    { type$ "proceedings" =
-        'editor.organization.sort
-        { type$ "manual" =
-            'author.organization.sort
-            'author.sort
-          if$
-        }
-      if$
-    }
-  if$
-#if LAB_ALPH
-  *
-#endif LAB_ALPH
-  "    "
-  *
-  year field.or.null sortify
-  *
-  "    "
-  *
-  title field.or.null
-  sort.format.title
-  *
-  #1 entry.max$ substring$
-  'sort.key$ :=
-}
-#else NAMED_REFS
-%                       apalike uses two sorting passes; the first one sets the
-%                       labels so that the `a's, `b's, etc. can be computed;
-%                       the second pass puts the references in "correct" order.
-%                       The presort function is for the first pass. It computes
-%                       label, sort.label, and title, and then concatenates.
-FUNCTION {presort}
-{ calc.label
-  label sortify
-  "    "
-  *
-  type$ "book" =
-  type$ "inbook" =
-  or
-    'author.editor.sort
-    { type$ "proceedings" =
-        'editor.sort
-        'author.sort
-      if$
-    }
-  if$
-  #1 entry.max$ substring$      % for
-  'sort.label :=                % apalike
-  sort.label                    % style
-  *
-  "    "
-  *
-  title field.or.null
-  sort.format.title
-  *
-  #1 entry.max$ substring$
-  'sort.key$ :=
-}
-#endif NAMED_REFS
-
-ITERATE {presort}
-
-% And now we can sort
-
-#if !NAMED_REFS
-SORT
-#else NAMED_REFS
-SORT            % by label, sort.label, title---for final label calculation
-#endif
-
-#endif SORTED
-
 % This long comment applies only to alphabetic labels, when sorted
 %
 % Now comes the final computation for alphabetic labels, putting in the 'a's
-% and 'b's and so forth if required.  This involves two passes: a forward
+% and 'b's and so forth if required. This involves two passes: a forward
 % pass to put in the 'b's, 'c's and so on, and a backwards pass
 % to put in the 'a's (we don't want to put in 'a's unless we know there
 % are 'b's).
@@ -3254,191 +1711,50 @@
 % by the "thebibliography" environment.
 %
 % VAR: longest.label, last.sort.label, next.extra: string
-%      longest.label.width, last.extra.num: integer
+% longest.label.width, last.extra.num: integer
 %
 % initialize.longest.label ==
-%  BEGIN
-%       longest.label := ""
-%       last.sort.label := int.to.chr$(0)
-%       next.extra := ""
-%       longest.label.width := 0
-%       last.extra.num := 0
-%  END
+% BEGIN
+% longest.label := ""
+% last.sort.label := int.to.chr$(0)
+% next.extra := ""
+% longest.label.width := 0
+% last.extra.num := 0
+% END
 %
 % forward.pass ==
-%  BEGIN
-%       if last.sort.label = sort.label then
-%           last.extra.num := last.extra.num + 1
-%           extra.label := int.to.chr$(last.extra.num)
-%       else
-%           last.extra.num := chr.to.int$("a")
-%           extra.label := ""
-%           last.sort.label := sort.label
-%       fi
-%  END
+% BEGIN
+% if last.sort.label = sort.label then
+% last.extra.num := last.extra.num + 1
+% extra.label := int.to.chr$(last.extra.num)
+% else
+% last.extra.num := chr.to.int$("a")
+% extra.label := ""
+% last.sort.label := sort.label
+% fi
+% END
 %
 % reverse.pass ==
-%  BEGIN
-%       if next.extra = "b" then
-%           extra.label := "a"
-%       fi
-%       label := label * extra.label
-%       if width$(label) > longest.label.width then
-%           longest.label := label
-%           longest.label.width := width$(label)
-%       fi
-%       next.extra := extra.label
-%  END
-
-#if LAB_ALPH
-
-#if SORTED
-
-#if !NAMED_REFS
-STRINGS { longest.label last.sort.label next.extra }
-
-INTEGERS { longest.label.width last.extra.num }
-
-FUNCTION {initialize.longest.label}
-{ "" 'longest.label :=
-  #0 int.to.chr$ 'last.sort.label :=
-  "" 'next.extra :=
-  #0 'longest.label.width :=
-  #0 'last.extra.num :=
-}
-
-FUNCTION {forward.pass}
-{ last.sort.label sort.label =
-    { last.extra.num #1 + 'last.extra.num :=
-      last.extra.num int.to.chr$ 'extra.label :=
-    }
-    { "a" chr.to.int$ 'last.extra.num :=
-      "" 'extra.label :=
-      sort.label 'last.sort.label :=
-    }
-  if$
-}
-#else NAMED_REFS
-STRINGS { last.label next.extra }       % apalike labels are only for the text;
-
-INTEGERS { last.extra.num }             % there are none in the bibliography
-
-FUNCTION {initialize.extra.label.stuff} % and hence there is no `longest.label'
-{ #0 int.to.chr$ 'last.label :=
-  "" 'next.extra :=
-  #0 'last.extra.num :=
-}
-
-FUNCTION {forward.pass}
-{ last.label label =
-    { last.extra.num #1 + 'last.extra.num :=
-      last.extra.num int.to.chr$ 'extra.label :=
-    }
-    { "a" chr.to.int$ 'last.extra.num :=
-      "" 'extra.label :=
-      label 'last.label :=
-    }
-  if$
-}
-#endif NAMED_REFS
-
-FUNCTION {reverse.pass}
-{ next.extra "b" =
-    { "a" 'extra.label := }
-    'skip$
-  if$
-  label extra.label * 'label :=
-#if !NAMED_REFS
-  label width$ longest.label.width >
-    { label 'longest.label :=
-      label width$ 'longest.label.width :=
-    }
-    'skip$
-  if$
-#endif !NAMED_REFS
-  extra.label 'next.extra :=
-}
-
-#if !NAMED_REFS
-EXECUTE {initialize.longest.label}
-#else NAMED_REFS
-EXECUTE {initialize.extra.label.stuff}
-#endif NAMED_REFS
-
-ITERATE {forward.pass}
-
-REVERSE {reverse.pass}
-
-#if NAMED_REFS
-%                               Now that the label is right we sort for real,
-%                               on sort.label then year then title.  This is
-%                               for the second sorting pass.
-FUNCTION {bib.sort.order}
-{ sort.label
-  "    "
-  *
-  year field.or.null sortify
-  *
-  "    "
-  *
-  title field.or.null
-  sort.format.title
-  *
-  #1 entry.max$ substring$
-  'sort.key$ :=
-}
-
-ITERATE {bib.sort.order}
-
-SORT            % by sort.label, year, title---giving final bibliography order
-#endif NAMED_REFS
-#else !SORTED
-
-% It still doesn't seem like a good idea to use an order-of-citation
-% reference list when using alphabetic labels, but when this happens we
-% must compute the longest label
-
-STRINGS { longest.label }
-
-INTEGERS { longest.label.width }
-
-FUNCTION {initialize.longest.label}
-{ "" 'longest.label :=
-  #0 'longest.label.width :=
-}
-
-FUNCTION {longest.label.pass}
-{ label width$ longest.label.width >
-    { label 'longest.label :=
-      label width$ 'longest.label.width :=
-    }
-    'skip$
-  if$
-}
-
-EXECUTE {initialize.longest.label}
-
-ITERATE {longest.label.pass}
-
-#endif SORTED
-
-#else !LAB_ALPH
-
+% BEGIN
+% if next.extra = "b" then
+% extra.label := "a"
+% fi
+% label := label * extra.label
+% if width$(label) > longest.label.width then
+% longest.label := label
+% longest.label.width := width$(label)
+% fi
+% next.extra := extra.label
+% END
 % Now comes the computation for numeric labels.
 % We use either the sorted order or original order.
 % We still have to keep track of the longest (in width$ terms) label, for use
 % by the "thebibliography" environment.
-
 STRINGS { longest.label }
-
 INTEGERS { number.label longest.label.width }
-
 FUNCTION {initialize.longest.label}
 { "" 'longest.label :=
-  #1 'number.label :=
-  #0 'longest.label.width :=
 }
-
 FUNCTION {longest.label.pass}
 { number.label int.to.str$ 'label :=
   number.label #1 + 'number.label :=
@@ -3449,72 +1765,30 @@
     'skip$
   if$
 }
-
 EXECUTE {initialize.longest.label}
-
 ITERATE {longest.label.pass}
-
-#endif LAB_ALPH
-
 % Now we're ready to start writing the .BBL file.
 % We begin, if necessary, with a LaTeX macro for unnamed names in an alphabetic
 % label; next comes stuff from the `preamble' command in the database files.
 % Then we give an incantation containing the command
-%     \begin{thebibliography}{...}
+% \begin{thebibliography}{...}
 % where the `...' is the longest label.
 %
 % We also call init.state.consts, for use by the output routines.
-
 FUNCTION {begin.bib}
-#if !NAMED_REFS
-#if LAB_ALPH
-{ et.al.char.used
-    { "\newcommand{\etalchar}[1]{$^{#1}$}" write$ newline$ }
-    'skip$
-  if$
-  preamble$ empty$
-#else !LAB_ALPH
 { preamble$ empty$
-#endif LAB_ALPH
-    'skip$
-    { preamble$ write$ newline$ }
-  if$
-  "\begin{thebibliography}{"  longest.label  * "}" * write$ newline$
-}
-#else NAMED_REFS
-{ preamble$ empty$                              % no \etalchar in apalike
     'skip$
     { preamble$ write$ newline$ }
   if$
-  "\begin{thebibliography}{}" write$ newline$           % no labels in apalike
+  "\begin{thebibliography}{" longest.label * "}" * write$ newline$
 }
-#endif NAMED_REFS
-
 EXECUTE {begin.bib}
-
 EXECUTE {init.state.consts}
-
 % Now we produce the output for all the entries
-
 ITERATE {call.type$}
-
 % Finally, we finish up by writing the `\end{thebibliography}' command.
-
 FUNCTION {end.bib}
 { newline$
   "\end{thebibliography}" write$ newline$
 }
-
 EXECUTE {end.bib}
-
-
-
-
-
-
-
-
-
-
-
-
